{
    "docs": [
        {
            "location": "/coherence-helidon-client/README",
            "text": "",
            "title": "Coherence Java CDI gRPC Client"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " Remote gRPC connections are configured using Helidon configuration, typically this would be a configuration file, but Helidon supports many ways to provide the configuration, or override the configuration with System properties or environment variables. The examples here will just use a configuration file. All gRPC channels are configured in the grpc.channels section of the application configuration. The example below is a simple configuration for a gRPC channel: <markup lang=\"yaml\" >grpc: channels: default: host: storage.acme.com port: 1408 The name of the channel is default . The host name of the gRPC server is storage.acme.com The port which the server is listening on is 1408 The default channel name is a special case that the Coherence gRPC client will use to locate a channel configuration if no channel name has been specified in CDI injection points. The example below shows a configuration with multiple channels, one named test and one named prod . <markup lang=\"yaml\" >grpc: channels: test: host: test.storage.acme.com port: 1408 prod: host: storage.acme.com port: 1408 The configuration may contain as many channels as required, the only stipulation being that each has a unique name. ",
            "title": "Configure gRPC Channels"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " The Coherence gRPC client will attempt to connect to a default server endpoint on localhost:1409 if no other channel has been configured. This is fine for development and testing but in most real-world applications the client will need to know the endpoint to connect to. Most applications would only require a channel to connect to a single Coherence cluster but there are use-cases where clients connect to multiple clusters, and the Coherence gRPC Java client supports these use-cases too. The Coherence gRPC client has been built on top of the Helidon Microprofile gRPC library and uses it to provide gRPC channels. Configure gRPC Channels Remote gRPC connections are configured using Helidon configuration, typically this would be a configuration file, but Helidon supports many ways to provide the configuration, or override the configuration with System properties or environment variables. The examples here will just use a configuration file. All gRPC channels are configured in the grpc.channels section of the application configuration. The example below is a simple configuration for a gRPC channel: <markup lang=\"yaml\" >grpc: channels: default: host: storage.acme.com port: 1408 The name of the channel is default . The host name of the gRPC server is storage.acme.com The port which the server is listening on is 1408 The default channel name is a special case that the Coherence gRPC client will use to locate a channel configuration if no channel name has been specified in CDI injection points. The example below shows a configuration with multiple channels, one named test and one named prod . <markup lang=\"yaml\" >grpc: channels: test: host: test.storage.acme.com port: 1408 prod: host: storage.acme.com port: 1408 The configuration may contain as many channels as required, the only stipulation being that each has a unique name. ",
            "title": "Remote Connections"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " By default, all sessions configured in Helidon configuration are gRPC client sessions. The type can be specifically set using the type property for the session configuration. There are two valid values for the grpc and coherence . A grpc session type specified that the session is a gRPC client session. A coherence type specifies that the session wraps a ConfigurableCacheFactory loaded from a Coherence configuration file. For example: <markup lang=\"yaml\" >coherence: sessions: products: type: grpc serializer: pof channel: prod extend: type: coherence configUri: coherence-config.xml The products session has a type: grpc property so it will be a gRPC client session. The `extend session will wrap a ConfigurableCacheFactory using the coherence-config.xml config file. ",
            "title": "Session Types"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " Coherence uses the concept of a Session to manage a set of related Coherence resources, such as maps, caches, topics, etc. When using the Coherence Java gRPC client a Session connects to a specific gRPC channel (described above) and uses a specific serialization format to marshal requests and responses. This means that different sessions using different serializers may connect to the same server endpoint. Typically, for efficiency the client and server would be configured to use matching serialization formats to avoid deserialization of data on the server but this does not have to be the case. If the server is using a different serializer for the server side caches it must be able to deserialize the client&#8217;s requests, so there must be a serializer configured on the server to match that used by the client. As with gRPC channels above, Coherence Sessions can be configured using Helidon configuration. Coherence sessions are configured in the coherence.sessions section of the configuration. Each session has its own entry in the configuration hierarchy, as shown below: <markup lang=\"yaml\" >coherence: sessions: default: serializer: pof channel: default The example above shows configuration for the default Coherence session, this is the session that will be used to provide Coherence beans when no session name has been specified for an injection point. In this example, the default session will use POF serialization and connect to the server using the default gRPC channel. The default session, if not configured, will use the default channel and will use Java serialization. As with channels, multiple sessions can be configured: <markup lang=\"yaml\" >coherence: sessions: test: serializer: pof channel: test prod: serializer: pof channel: prod # Helidon gRPC configuration grpc: channels: - name: test host: test.storage.acme.com port: 1408 - name: prod host: storage.acme.com port: 1408 In the example above, there are two Coherence sessions configured and two corresponding gRPC channels. Session Types By default, all sessions configured in Helidon configuration are gRPC client sessions. The type can be specifically set using the type property for the session configuration. There are two valid values for the grpc and coherence . A grpc session type specified that the session is a gRPC client session. A coherence type specifies that the session wraps a ConfigurableCacheFactory loaded from a Coherence configuration file. For example: <markup lang=\"yaml\" >coherence: sessions: products: type: grpc serializer: pof channel: prod extend: type: coherence configUri: coherence-config.xml The products session has a type: grpc property so it will be a gRPC client session. The `extend session will wrap a ConfigurableCacheFactory using the coherence-config.xml config file. ",
            "title": "Coherence gRPC Sessions"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " A number of commonly used Coherence objects can be injected when using Java gRPC client. ",
            "title": "Injecting Coherence Objects into CDI Beans"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " In order to inject an instance of a NamedMap into your gRPC client CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >@Inject private NamedMap&lt;Long, Person&gt; people; <markup lang=\"java\" >@Inject @SesionName(\"products\") private NamedMap&lt;Long, Product&gt; products; In this example the Coherence CDI extensions will use the products session to provide the client side NamedMap backed on the server by a NamedMap called products . Other remote resources, such a NamedCache can be injected the same way: <markup lang=\"java\" >@Inject private NamedCache&lt;Long, Product&gt; products; The Coherence CDI documentation covers the different types of resources supported by CDI. When using them with the gRPC Java client. ",
            "title": "Injecting NamedMap NamedCache and Related Objects"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " If an application bean requires multiple maps or caches where the names will only be known at runtime then a Coherence com.tangosol.net.Session can be injected instead of other specific named resources. The required maps or caches can then be obtained from the Session by calling methods such as Session.getMap or Session.getCache , etc. <markup lang=\"java\" >@Inject @Name(\"products\") private Session session; The @Name qualifier has the value products , so the Session injected here will be the pre-configured Session named products . ",
            "title": "Injecting Sessions"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " The observer method above will receive all events for the people map, but you can also control the types of events received using event type qualifiers. Qualifier Description @Inserted Observes insert events, raised when new entries are added to a map or cache. @Updated Observes update events, raised when entries in a map or cache are modified. @Deleted Observes deleted events, raised when entries are deleted from a map or cache. For example: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onAddOrRemove(@Observes @Inserted @Deleted @MapName(\"people\") MapEvent&lt;?, ?&gt; event) { // handle INSERTED and DELETED events raised by the 'people' map/cache } The first observer method above will observe only update events. Multiple event type qualifiers can be added, so the second observer method will observer insert or delete events. Note The client supports connecting to a server using different named Sessions and different named Scopes . The observer methods above are not qualified with either session name or scope name so will observe events for all maps or caches with the name people in all sessions and scopes. In most Coherence use-cases that only use a single client session and a single default server side scope this is not an issue but is something to be aware of if using multiple sessiosn or scopes. See the following sections on how to qualify the observer to restrict the maps and caches it observes. ",
            "title": "Observe Specific Event Types"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " In addition, to the @MapName qualifier, you can also specify a Session name as a way to limit the events received to maps or caches from a specific Session . This is achieved by specifying a value for the @SessionName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"test\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the test Session. } In the example above the @SesionName qualifier has a value test , so the events will only be observed from the people map on the server that corresponds to the map of the same name owned by the client side Session named test . Note Maps or caches in different client side Sessions may correspond to the same server side map or cache and hence events in one server side map or cache can be observed by multiple client side observers. For example: Suppose a Map named people has been created in the default scope on the server. On the client there are two Sessions configured, session-one and session-two but both of these connect to the same server and have the same default scope. The two observers below are on the client: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"session-one\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } private void onMapChange(@Observes @SesionName(\"session-two\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } In this case both observer methods are actually observing the same server-side map and will receive the same events event though they have different qualifiers. ",
            "title": "Observe Events for Maps and Caches from Specific Sessions"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " In addition, to the @MapName qualifier, you can also specify a scope name as a way to limit the events received to maps or caches from a specific server-side scope name. This is achieved by specifying a value for the @ScopeName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@ObservesAsync @ScopeName(\"employees\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the employees scope. } In the example above the @ScopeName qualifier has a value employees , so the events will only be observed from the people map in by the scope named employees on the server. ",
            "title": "Observe Events for Maps and Caches from Specific Server-side Scopes"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } ",
            "title": "Filter Observed Events"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values, and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type MapEvent&lt;Long, Person&gt; this method will receive events of type MapEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type MapEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. ",
            "title": "Transform Observed Events"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " All the examples above used synchronous observers by specifying the @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onMapChange(@ObservesAsync @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } ",
            "title": "Using Asynchronous Observers"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " The Coherence NamedMap and NamedCache APIs allow implementations of MapListener to be added that will then receive events as map/cache entries get inserted, updated or deleted. When using CDI it is possible to subscribe to the same events using CDI observer methods. For example, to observe events raised by a NamedMap with the name people , with keys of type Long and values of type Person , you would define a CDI observer such as this one: <markup lang=\"java\" >private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } The Observes qualifier is what makes this method a standard CDI observer. The MapName qualifier determines which map/cache to observer. If this qualifier is not present events from all caches will be observed. Observe Specific Event Types The observer method above will receive all events for the people map, but you can also control the types of events received using event type qualifiers. Qualifier Description @Inserted Observes insert events, raised when new entries are added to a map or cache. @Updated Observes update events, raised when entries in a map or cache are modified. @Deleted Observes deleted events, raised when entries are deleted from a map or cache. For example: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onAddOrRemove(@Observes @Inserted @Deleted @MapName(\"people\") MapEvent&lt;?, ?&gt; event) { // handle INSERTED and DELETED events raised by the 'people' map/cache } The first observer method above will observe only update events. Multiple event type qualifiers can be added, so the second observer method will observer insert or delete events. Note The client supports connecting to a server using different named Sessions and different named Scopes . The observer methods above are not qualified with either session name or scope name so will observe events for all maps or caches with the name people in all sessions and scopes. In most Coherence use-cases that only use a single client session and a single default server side scope this is not an issue but is something to be aware of if using multiple sessiosn or scopes. See the following sections on how to qualify the observer to restrict the maps and caches it observes. Observe Events for Maps and Caches from Specific Sessions In addition, to the @MapName qualifier, you can also specify a Session name as a way to limit the events received to maps or caches from a specific Session . This is achieved by specifying a value for the @SessionName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"test\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the test Session. } In the example above the @SesionName qualifier has a value test , so the events will only be observed from the people map on the server that corresponds to the map of the same name owned by the client side Session named test . Note Maps or caches in different client side Sessions may correspond to the same server side map or cache and hence events in one server side map or cache can be observed by multiple client side observers. For example: Suppose a Map named people has been created in the default scope on the server. On the client there are two Sessions configured, session-one and session-two but both of these connect to the same server and have the same default scope. The two observers below are on the client: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"session-one\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } private void onMapChange(@Observes @SesionName(\"session-two\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } In this case both observer methods are actually observing the same server-side map and will receive the same events event though they have different qualifiers. Observe Events for Maps and Caches from Specific Server-side Scopes In addition, to the @MapName qualifier, you can also specify a scope name as a way to limit the events received to maps or caches from a specific server-side scope name. This is achieved by specifying a value for the @ScopeName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@ObservesAsync @ScopeName(\"employees\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the employees scope. } In the example above the @ScopeName qualifier has a value employees , so the events will only be observed from the people map in by the scope named employees on the server. Filter Observed Events The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Transform Observed Events When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values, and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type MapEvent&lt;Long, Person&gt; this method will receive events of type MapEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type MapEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. Using Asynchronous Observers All the examples above used synchronous observers by specifying the @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onMapChange(@ObservesAsync @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } ",
            "title": "Using CDI Observers to Handle MapEvents"
        },
        {
            "location": "/coherence-helidon-client/README",
            "text": " The Coherence gRPC Helidon client is a CDI enabled library that allows Java clients to connect via gRPC to a Coherence proxy server. This library has a dependency on Helidon for some services. In order to use Coherence gRPC Helidon client, you need to declare it as a dependency in your pom.xml <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-helidon-client&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; Using the Coherence gRPC Helidon client assumes that there is a corresponding server process running which is using the Coherence gRPC proxy service to expose the required gRPC endpoints. Once the necessary dependency is in place, the simplest way to start using it is to just inject Coherence resources into the application&#8217;s beans. A lot of the annotations and qualifiers are identical to those described in the Coherence CDI documentation. The following sections describe different injection points in more detail. Configuring gRPC Connections Configuring Coherence Remote Sessions Injecting Coherence Objects into CDI Beans Injecting NamedMap , NamedCache , and related objects Session Injection Using CDI Observers to Handle Coherence Map or Cache Events Observer specific event types Filter the events to be observed Transform the events to be observed Observe events for maps and caches owned by a specific Session Observe events for maps and caches in specific scopes or services Using Asynchronous Observers Remote Connections The Coherence gRPC client will attempt to connect to a default server endpoint on localhost:1409 if no other channel has been configured. This is fine for development and testing but in most real-world applications the client will need to know the endpoint to connect to. Most applications would only require a channel to connect to a single Coherence cluster but there are use-cases where clients connect to multiple clusters, and the Coherence gRPC Java client supports these use-cases too. The Coherence gRPC client has been built on top of the Helidon Microprofile gRPC library and uses it to provide gRPC channels. Configure gRPC Channels Remote gRPC connections are configured using Helidon configuration, typically this would be a configuration file, but Helidon supports many ways to provide the configuration, or override the configuration with System properties or environment variables. The examples here will just use a configuration file. All gRPC channels are configured in the grpc.channels section of the application configuration. The example below is a simple configuration for a gRPC channel: <markup lang=\"yaml\" >grpc: channels: default: host: storage.acme.com port: 1408 The name of the channel is default . The host name of the gRPC server is storage.acme.com The port which the server is listening on is 1408 The default channel name is a special case that the Coherence gRPC client will use to locate a channel configuration if no channel name has been specified in CDI injection points. The example below shows a configuration with multiple channels, one named test and one named prod . <markup lang=\"yaml\" >grpc: channels: test: host: test.storage.acme.com port: 1408 prod: host: storage.acme.com port: 1408 The configuration may contain as many channels as required, the only stipulation being that each has a unique name. Coherence gRPC Sessions Coherence uses the concept of a Session to manage a set of related Coherence resources, such as maps, caches, topics, etc. When using the Coherence Java gRPC client a Session connects to a specific gRPC channel (described above) and uses a specific serialization format to marshal requests and responses. This means that different sessions using different serializers may connect to the same server endpoint. Typically, for efficiency the client and server would be configured to use matching serialization formats to avoid deserialization of data on the server but this does not have to be the case. If the server is using a different serializer for the server side caches it must be able to deserialize the client&#8217;s requests, so there must be a serializer configured on the server to match that used by the client. As with gRPC channels above, Coherence Sessions can be configured using Helidon configuration. Coherence sessions are configured in the coherence.sessions section of the configuration. Each session has its own entry in the configuration hierarchy, as shown below: <markup lang=\"yaml\" >coherence: sessions: default: serializer: pof channel: default The example above shows configuration for the default Coherence session, this is the session that will be used to provide Coherence beans when no session name has been specified for an injection point. In this example, the default session will use POF serialization and connect to the server using the default gRPC channel. The default session, if not configured, will use the default channel and will use Java serialization. As with channels, multiple sessions can be configured: <markup lang=\"yaml\" >coherence: sessions: test: serializer: pof channel: test prod: serializer: pof channel: prod # Helidon gRPC configuration grpc: channels: - name: test host: test.storage.acme.com port: 1408 - name: prod host: storage.acme.com port: 1408 In the example above, there are two Coherence sessions configured and two corresponding gRPC channels. Session Types By default, all sessions configured in Helidon configuration are gRPC client sessions. The type can be specifically set using the type property for the session configuration. There are two valid values for the grpc and coherence . A grpc session type specified that the session is a gRPC client session. A coherence type specifies that the session wraps a ConfigurableCacheFactory loaded from a Coherence configuration file. For example: <markup lang=\"yaml\" >coherence: sessions: products: type: grpc serializer: pof channel: prod extend: type: coherence configUri: coherence-config.xml The products session has a type: grpc property so it will be a gRPC client session. The `extend session will wrap a ConfigurableCacheFactory using the coherence-config.xml config file. Injecting Coherence Objects into CDI Beans A number of commonly used Coherence objects can be injected when using Java gRPC client. Injecting NamedMap NamedCache and Related Objects In order to inject an instance of a NamedMap into your gRPC client CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >@Inject private NamedMap&lt;Long, Person&gt; people; <markup lang=\"java\" >@Inject @SesionName(\"products\") private NamedMap&lt;Long, Product&gt; products; In this example the Coherence CDI extensions will use the products session to provide the client side NamedMap backed on the server by a NamedMap called products . Other remote resources, such a NamedCache can be injected the same way: <markup lang=\"java\" >@Inject private NamedCache&lt;Long, Product&gt; products; The Coherence CDI documentation covers the different types of resources supported by CDI. When using them with the gRPC Java client. Injecting Sessions If an application bean requires multiple maps or caches where the names will only be known at runtime then a Coherence com.tangosol.net.Session can be injected instead of other specific named resources. The required maps or caches can then be obtained from the Session by calling methods such as Session.getMap or Session.getCache , etc. <markup lang=\"java\" >@Inject @Name(\"products\") private Session session; The @Name qualifier has the value products , so the Session injected here will be the pre-configured Session named products . Using CDI Observers to Handle MapEvents The Coherence NamedMap and NamedCache APIs allow implementations of MapListener to be added that will then receive events as map/cache entries get inserted, updated or deleted. When using CDI it is possible to subscribe to the same events using CDI observer methods. For example, to observe events raised by a NamedMap with the name people , with keys of type Long and values of type Person , you would define a CDI observer such as this one: <markup lang=\"java\" >private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } The Observes qualifier is what makes this method a standard CDI observer. The MapName qualifier determines which map/cache to observer. If this qualifier is not present events from all caches will be observed. Observe Specific Event Types The observer method above will receive all events for the people map, but you can also control the types of events received using event type qualifiers. Qualifier Description @Inserted Observes insert events, raised when new entries are added to a map or cache. @Updated Observes update events, raised when entries in a map or cache are modified. @Deleted Observes deleted events, raised when entries are deleted from a map or cache. For example: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onAddOrRemove(@Observes @Inserted @Deleted @MapName(\"people\") MapEvent&lt;?, ?&gt; event) { // handle INSERTED and DELETED events raised by the 'people' map/cache } The first observer method above will observe only update events. Multiple event type qualifiers can be added, so the second observer method will observer insert or delete events. Note The client supports connecting to a server using different named Sessions and different named Scopes . The observer methods above are not qualified with either session name or scope name so will observe events for all maps or caches with the name people in all sessions and scopes. In most Coherence use-cases that only use a single client session and a single default server side scope this is not an issue but is something to be aware of if using multiple sessiosn or scopes. See the following sections on how to qualify the observer to restrict the maps and caches it observes. Observe Events for Maps and Caches from Specific Sessions In addition, to the @MapName qualifier, you can also specify a Session name as a way to limit the events received to maps or caches from a specific Session . This is achieved by specifying a value for the @SessionName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"test\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the test Session. } In the example above the @SesionName qualifier has a value test , so the events will only be observed from the people map on the server that corresponds to the map of the same name owned by the client side Session named test . Note Maps or caches in different client side Sessions may correspond to the same server side map or cache and hence events in one server side map or cache can be observed by multiple client side observers. For example: Suppose a Map named people has been created in the default scope on the server. On the client there are two Sessions configured, session-one and session-two but both of these connect to the same server and have the same default scope. The two observers below are on the client: <markup lang=\"java\" >private void onMapChange(@Observes @SesionName(\"session-one\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } private void onMapChange(@Observes @SesionName(\"session-two\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { //... } In this case both observer methods are actually observing the same server-side map and will receive the same events event though they have different qualifiers. Observe Events for Maps and Caches from Specific Server-side Scopes In addition, to the @MapName qualifier, you can also specify a scope name as a way to limit the events received to maps or caches from a specific server-side scope name. This is achieved by specifying a value for the @ScopeName qualifier. See the Sessions section for more details on multiple `Session`s. For example: <markup lang=\"java\" >private void onMapChange(@ObservesAsync @ScopeName(\"employees\") @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache owned by the employees scope. } In the example above the @ScopeName qualifier has a value employees , so the events will only be observed from the people map in by the scope named employees on the server. Filter Observed Events The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Transform Observed Events When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values, and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type MapEvent&lt;Long, Person&gt; this method will receive events of type MapEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") MapEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type MapEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. Using Asynchronous Observers All the examples above used synchronous observers by specifying the @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onMapChange(@ObservesAsync @MapName(\"people\") MapEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } ",
            "title": "Usage"
        },
        {
            "location": "/coherence-docker/README",
            "text": " The Coherence image uses a distroless base image containing OpenJDK. There are many advantages of a distroless image, security being the main one. Of course, you are free to use whatever base image or build mechanism you want for your own images. The image built by the coherence-docker module contains the following Coherence components: Component Description Coherence The core Coherence server Coherence Extend A Coherence*Extend proxy, exposed on port 20000 Coherence gRPC Proxy A Coherence gRPC proxy, exposed on port 1408 Coherence Management Coherence Management over REST, exposed on port 30000 Coherence Metrics Standard Coherence metrics is installed and exposed on port 9612 , but is disabled by default. Coherence metrics can be enabled with the System property coherence.metrics.http.enabled=true Coherence Tracing Coherence tracing is configured to use a Jaeger tracing server. See the Tracing section below. ",
            "title": "Image Contents"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Assuming you have first cloned the Coherence CE project the to build the Coherence image run the following command from the top-level Maven prj/ folder: <markup lang=\"bash\" >mvn clean install -P docker -pl coherence-docker The name of the image produced comes from properties in the coherence-docker module pom.xml file. ${docker.registry}/coherence-ce:&lt;version&gt; Where &lt;version&gt; , is the version of the product from the pom.xml file. The ${docker.registry} property is the name of the registry that the image will be published to, by default this is oraclecoherence . So, if the version in the pom.xml is 20.12.1 the image produced will be oraclecoherence/coherence-ce:20.12.1 To change the registry name the image can be built by specifying the docker.registry property, for example: <markup lang=\"bash\" >mvn clean install -P docker -pl coherence-docker -Ddocker.registry=foo The example above would build an image named foo/coherence:20.12.1 ",
            "title": "Building the Image"
        },
        {
            "location": "/coherence-docker/README",
            "text": " This image can be run in Kubernetes using the Coherence Operator . The sections below on additional configurations do not apply when using the Coherence Operator to run the image in Kubernetes. The operator provides functionality to configure the container correctly. ",
            "title": "Run the Image in Kubernetes"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Run the image just like any other image. In Docker this command would be: <markup lang=\"bash\" >docker run -d -P oraclecoherence/coherence-ce:{version-coherence-maven} The -P parameter will ensure that the Extend, gRPC, management and metrics ports will all be exposed. By default, when started the image will run com.tangosol.net.DefaultCacheServer . This may be changed by setting the COH_MAIN_CLASS environment variable to the name of another main class. <markup lang=\"bash\" >docker run -d -P \\ -e COH_MAIN_CLASS=com.tangosol.net.DefaultCacheServer \\ oraclecoherence/coherence-ce:{version-coherence-maven} Run the Image in Kubernetes This image can be run in Kubernetes using the Coherence Operator . The sections below on additional configurations do not apply when using the Coherence Operator to run the image in Kubernetes. The operator provides functionality to configure the container correctly. ",
            "title": "Run the image"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Many options in Coherence can be set from System properties prefixed with coherence. . The issue here is that System properties are not very easy to pass into the JVM in the container, whereas environment variables are. To help with this the main class which runs in the container will convert any environment variable prefixed with coherence. into a System property before it starts Coherence. <markup lang=\"bash\" >docker run -d -P \\ -e coherence.cluster=testing \\ -e coherence.role=storage \\ oraclecoherence/coherence-ce:{version-coherence-maven} The example above sets two environment variables, coherence.cluster=testing and coherence.role=storage . These will be converted to System properties so Coherence will start the same as it would if the variables had been passed to the JVM command line as -Dcoherence.cluster=testing -Dcoherence.role=storage This only applies to environment variables prefixed with coherence. that have not already set as System properties some other way. ",
            "title": "Specifying Coherence System Properties"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Images built with JIB have a fixed entrypoint configured to run the application. This is not very flexible if additional options need to be passed to the JVM. The Coherence image makes use of the JVM&#8217;s ability to load options at start-up from a file by using a JVM option @&lt;file-name&gt; . The Coherence image entrypoint contains @/args/jvm-args.txt , so the JVM will load additional options on start-up from a file named /args/jvm-args.txt . This means that additional options can be provided by adding a volume mapping that adds this file to the container. For example, to set the heap to 5g, the Coherence cluster name to test-cluster and role name to storage then additional JVM arguments will be required. Create a file named jvm-args.txt containing these properties: <markup title=\"jvm-args.txt\" >-Xms5g -Xmx5g -Dcoherence.cluster=test-cluster -Dcoherence.role=storage If the file has been created in a local directory named /home/oracle/test-args then the image can be run with the following command: <markup lang=\"bash\" >docker run -d -P -v /home/oracle/test-args:/args oraclecoherence/coherence-ce:{version-coherence-maven} This will cause Docker to mount the local /home/oracle/test-args directory to the /args directory in the container where the JVM will find the jvm-args.txt file. ",
            "title": "Specifying JVM Options"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Images built with JIB have a fixed classpath configured, which is not very flexible if additional resources need to be added to the classpath. The Coherence image maps two additional directories to the classpath that are empty in the image and may be used to add items to the classpath by mapping external volumes to these directories. The additional classpath entries are: /coherence/ext/lib/* - this will add all .jar files under the /coherence/ext/lib/ directory to the classpath /coherence/ext/conf - this adds /coherence/ext/conf to the classpath so that any classes, packages or other resource files in this directory will be added to the classpath. For example: On the local Docker host there is a folder called /dev/my-app/lib that contains .jar files to be added to the container classpath. <markup lang=\"bash\" >docker run -d -P -v /dev/my-app/lib:/coherence/ext/lib oraclecoherence/coherence-ce:{version-coherence-maven} The command above maps the local directory /dev/my-app/lib to the /coherence/ext/lib in the container so that any .jar files in the /dev/my-app/lib directory will now be on the Coherence JVM&#8217;s classpath. On the local Docker host there is a folder called /dev/my-app/classes that contains .class files and other application resources to be added to the container classpath. <markup lang=\"bash\" >docker run -d -P -v /dev/my-app/classes:/coherence/ext/conf oraclecoherence/coherence-ce:{version-coherence-maven} The command above maps the local directory /dev/my-app/classes to the /coherence/ext/conf in the container so that any classes and resource files in the /dev/my-app/classes directory will now be on the Coherence JVM&#8217;s classpath. ",
            "title": "Adding to the Classpath"
        },
        {
            "location": "/coherence-docker/README",
            "text": " This module builds an example Coherence OCI compatible image. The image built in this module is a demo and example of how to build a Coherence image using the JIB Maven Plugin . The image is not intended to be used in production deployments or as a base image, it is specifically for demos, experimentation and learning purposes. Image Contents The Coherence image uses a distroless base image containing OpenJDK. There are many advantages of a distroless image, security being the main one. Of course, you are free to use whatever base image or build mechanism you want for your own images. The image built by the coherence-docker module contains the following Coherence components: Component Description Coherence The core Coherence server Coherence Extend A Coherence*Extend proxy, exposed on port 20000 Coherence gRPC Proxy A Coherence gRPC proxy, exposed on port 1408 Coherence Management Coherence Management over REST, exposed on port 30000 Coherence Metrics Standard Coherence metrics is installed and exposed on port 9612 , but is disabled by default. Coherence metrics can be enabled with the System property coherence.metrics.http.enabled=true Coherence Tracing Coherence tracing is configured to use a Jaeger tracing server. See the Tracing section below. Building the Image Assuming you have first cloned the Coherence CE project the to build the Coherence image run the following command from the top-level Maven prj/ folder: <markup lang=\"bash\" >mvn clean install -P docker -pl coherence-docker The name of the image produced comes from properties in the coherence-docker module pom.xml file. ${docker.registry}/coherence-ce:&lt;version&gt; Where &lt;version&gt; , is the version of the product from the pom.xml file. The ${docker.registry} property is the name of the registry that the image will be published to, by default this is oraclecoherence . So, if the version in the pom.xml is 20.12.1 the image produced will be oraclecoherence/coherence-ce:20.12.1 To change the registry name the image can be built by specifying the docker.registry property, for example: <markup lang=\"bash\" >mvn clean install -P docker -pl coherence-docker -Ddocker.registry=foo The example above would build an image named foo/coherence:20.12.1 Run the image Run the image just like any other image. In Docker this command would be: <markup lang=\"bash\" >docker run -d -P oraclecoherence/coherence-ce:{version-coherence-maven} The -P parameter will ensure that the Extend, gRPC, management and metrics ports will all be exposed. By default, when started the image will run com.tangosol.net.DefaultCacheServer . This may be changed by setting the COH_MAIN_CLASS environment variable to the name of another main class. <markup lang=\"bash\" >docker run -d -P \\ -e COH_MAIN_CLASS=com.tangosol.net.DefaultCacheServer \\ oraclecoherence/coherence-ce:{version-coherence-maven} Run the Image in Kubernetes This image can be run in Kubernetes using the Coherence Operator . The sections below on additional configurations do not apply when using the Coherence Operator to run the image in Kubernetes. The operator provides functionality to configure the container correctly. Specifying Coherence System Properties Many options in Coherence can be set from System properties prefixed with coherence. . The issue here is that System properties are not very easy to pass into the JVM in the container, whereas environment variables are. To help with this the main class which runs in the container will convert any environment variable prefixed with coherence. into a System property before it starts Coherence. <markup lang=\"bash\" >docker run -d -P \\ -e coherence.cluster=testing \\ -e coherence.role=storage \\ oraclecoherence/coherence-ce:{version-coherence-maven} The example above sets two environment variables, coherence.cluster=testing and coherence.role=storage . These will be converted to System properties so Coherence will start the same as it would if the variables had been passed to the JVM command line as -Dcoherence.cluster=testing -Dcoherence.role=storage This only applies to environment variables prefixed with coherence. that have not already set as System properties some other way. Specifying JVM Options Images built with JIB have a fixed entrypoint configured to run the application. This is not very flexible if additional options need to be passed to the JVM. The Coherence image makes use of the JVM&#8217;s ability to load options at start-up from a file by using a JVM option @&lt;file-name&gt; . The Coherence image entrypoint contains @/args/jvm-args.txt , so the JVM will load additional options on start-up from a file named /args/jvm-args.txt . This means that additional options can be provided by adding a volume mapping that adds this file to the container. For example, to set the heap to 5g, the Coherence cluster name to test-cluster and role name to storage then additional JVM arguments will be required. Create a file named jvm-args.txt containing these properties: <markup title=\"jvm-args.txt\" >-Xms5g -Xmx5g -Dcoherence.cluster=test-cluster -Dcoherence.role=storage If the file has been created in a local directory named /home/oracle/test-args then the image can be run with the following command: <markup lang=\"bash\" >docker run -d -P -v /home/oracle/test-args:/args oraclecoherence/coherence-ce:{version-coherence-maven} This will cause Docker to mount the local /home/oracle/test-args directory to the /args directory in the container where the JVM will find the jvm-args.txt file. Adding to the Classpath Images built with JIB have a fixed classpath configured, which is not very flexible if additional resources need to be added to the classpath. The Coherence image maps two additional directories to the classpath that are empty in the image and may be used to add items to the classpath by mapping external volumes to these directories. The additional classpath entries are: /coherence/ext/lib/* - this will add all .jar files under the /coherence/ext/lib/ directory to the classpath /coherence/ext/conf - this adds /coherence/ext/conf to the classpath so that any classes, packages or other resource files in this directory will be added to the classpath. For example: On the local Docker host there is a folder called /dev/my-app/lib that contains .jar files to be added to the container classpath. <markup lang=\"bash\" >docker run -d -P -v /dev/my-app/lib:/coherence/ext/lib oraclecoherence/coherence-ce:{version-coherence-maven} The command above maps the local directory /dev/my-app/lib to the /coherence/ext/lib in the container so that any .jar files in the /dev/my-app/lib directory will now be on the Coherence JVM&#8217;s classpath. On the local Docker host there is a folder called /dev/my-app/classes that contains .class files and other application resources to be added to the container classpath. <markup lang=\"bash\" >docker run -d -P -v /dev/my-app/classes:/coherence/ext/conf oraclecoherence/coherence-ce:{version-coherence-maven} The command above maps the local directory /dev/my-app/classes to the /coherence/ext/conf in the container so that any classes and resource files in the /dev/my-app/classes directory will now be on the Coherence JVM&#8217;s classpath. ",
            "title": "Coherence OCI Image"
        },
        {
            "location": "/coherence-docker/README",
            "text": " Multiple containers can be started to form a cluster. By default, Coherence uses multi-cast for cluster discovery but in containers this either will not work, or is not reliable, so well-known-addressing can be used. This example is going to use basic Docker commands and links between containers. There are other ways to achieve the same sort of functionality depending on the network configurations you want to use in Docker. First, determine the name to be used for the first container, in this example it will be storage-1 . Next, create a ` Start the first container in the cluster: <markup lang=\"bash\" >docker run -d -P \\ --name storage-1 \\ --hostname storage-1 \\ -e coherence.wka=storage-1 \\ -e coherence.cluster=testing \\ oraclecoherence/coherence-ce:{version-coherence-maven} The first container has been started with a container name of storage-1 , and the host name also set to storage-1 . The container sets the WKA host name to storage-1 using -e coherence.wka=storage-1 (this will be converted to the System property coherence.wka=storage-1 see Specifying Coherence System Properties above). The container sets the Coherence cluster name to testing using -e coherence.cluster=testing (this will be converted to the System property coherence.cluster=testing see Specifying Coherence System Properties above). The important part here is that the container has a name, and the --hostname option has also been set. This will allow the subsequent cluster members to find this container. Now, subsequent containers can be started using the same cluster name and WKA host name, but with different container names and a link to the first container, all the containers will form a single Coherence cluster: <markup lang=\"bash\" >docker run -d -P \\ --name storage-2 \\ --link storage-1 \\ -e coherence.wka=storage-1 \\ -e coherence.cluster=testing \\ oraclecoherence/coherence-ce:{version-coherence-maven} docker run -d -P \\ --name storage-3 \\ --link storage-1 \\ -e coherence.wka=storage-1 \\ -e coherence.cluster=testing \\ oraclecoherence/coherence-ce:{version-coherence-maven} Two more containers, storage-2 and storage-3 will now be part of the cluster. All the members must have a --link option to the first container and have the same WKA and cluster name properties. ",
            "title": "Clustering"
        },
        {
            "location": "/coherence-docker/README",
            "text": " The Coherence image comes with tracing already configured, it just requires a suitable Jaeger server to send spans to. The simplest way to start is deploy the Jaeger all-in-one server, for example: <markup lang=\"bash\" >docker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ -p 9411:9411 \\ jaegertracing/all-in-one:latest The Jaeger UI will be available to browse to at http://127.0.0.1:16686 Jaeger has been started with a container name of jaeger , so it will be discoverable using that host name by the Coherence containers. Start the Coherence container with a link to the Jaeger container and set the JAEGER_AGENT_HOST environment variable to jaeger : <markup lang=\"bash\" >docker run -d -P --link jaeger \\ -e JAEGER_AGENT_HOST=jaeger \\ oraclecoherence/coherence-ce:{version-coherence-maven} Once the Coherence container is running perform some interactions with it using one of the exposed services, i.e Extend or gRPC, and spans will be sent to the Jaeger collector and will be visible in the UI by querying for the coherence service name. The service name used can be changed by setting the JAEGER_SERVICE_NAME environment variable when starting the container, for example: <markup lang=\"bash\" >docker run -d -P --link jaeger \\ -e JAEGER_AGENT_HOST=jaeger \\ -e JAEGER_SERVICE_NAME=coherence-test oraclecoherence/coherence-ce:{version-coherence-maven} Spans will now be sent to Jaeger with the service name coherence-test . Tracing is very useful to show what happens under the covers for a given Coherence API call. Traces are more interesting when they come from a Coherence cluster with multiple members, where the traces span different cluster members. This can easily be done by running multiple containers with tracing enabled and configuring Clustering as described above. ",
            "title": "Tracing"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Portable Types provide a way to add support for POF serialization to your classes via annotations and without the need to implement serialization code by hand, just like POF Annotations did. However, unlike POF Annotations, Portable Types: Implement serialization code at compile-time using byte code instrumentation, and do not rely on Java reflection at runtime at all. This makes them just as fast, but less error-prone, as manually implemented serialization code. Support, but do not require explicit registration via POF config file, as all the metadata required for POF type registration, such as type identifier, and the serializer class to use, are already available in the @PortableType annotation. Fully support class evolution. As a matter of fact, Portable Types provide a better and more complete evolution support than if you implemented Evolvable interface by hand. One of the limitations of Evolvable is that it only supports evolution of the leaf classes in the class hierarchy. Portable Types do not have this limitation, and allow you not only to evolve any class in the hierarchy, but also to evolve the class hierarchy itself, by adding new classes to any level of the class hierarchy. When we first introduced POF back in 2006, it was never the goal to require manual implementation of the serialization code&#8201;&#8212;&#8201;we always wanted to provide the tooling that would do the heavy lifting and allow users to simply express their intent via annotations. It may have taken us almost 15 years, but we feel that with the release of Portable Types, we are finally there. ",
            "title": "Features and Benefits"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " There are only two basic requirements for Portable Types: The class must be annotated with @PortableType annotation, and The fields that should be serialized must be annotated with @Portable or one of related annotations ( @PortableDate , @PortableArray , @PortableSet , @PortableList , or @PortableMap ) <markup lang=\"java\" >@PortableType(id = 1) public class Pet { @Portable protected String name; // constructors, accessors, etc. } @PortableType(id = 2) public class Dog extends Pet { @Portable private String breed; // constructors, accessors, etc. } Additional attribute-level annotations allow you to control certain serialization behaviors that are specific to the type of the attribute. For example, @PortableDate allows you to control whether you want to serialize date, time, or both when serializing java.util.Date instances (via mode property), and whether time zone information should be included (via includeTimezone property). If you are using Java 8 (or later) java.time classes, that information can be derived from the class itself, so you can (and should) simply use @Portable annotation instead. For example, LocalTime will be serialized as time only, with no time zone information, while the OffsetDateTime will be serialized as both date and time, with time zone information. Similarly, when serializing arrays, collections and maps, POF allows you to use uniform encoding , where the element type (or key and/or value type, in case of maps) is written into the POF stream only once, instead of once for each element of the collection, resulting in a more compact serialized form. <markup lang=\"java\" >public class MyClass { @PortableArray(elementClass = String.class) private String[] m_stringArray; @PortableSet(elementClass = String.class, clazz = LinkedHashSet.class) private Set&lt;String&gt; m_setOfStrings; @PortableList(elementClass = String.class) private List&lt;String&gt; m_listOfStrings; @PortableMap(keyClass = Integer.class, valueClass = String.class, clazz = TreeMap.class) private Map&lt;Integer, String&gt; m_uniformMap; } As you can see from the examples above, these annotations also allow you to specify the concrete class that should be created during deserialization for a given attribute. If the clazz property is not specified, HashSet will be used as a default set type, ArrayList as a default list type, and HashMap as a default map type. ",
            "title": "Usage Basics"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Coherence is a distributed system, and there is no guarantee that every cluster member, and every client process that connects to the cluster, will have the same version of each and every class. As a matter of fact, for systems that use rolling upgrades in order to avoid any downtime, it is pretty much guaranteed that they won&#8217;t! It is also neither safe nor practical for most Coherence customers to upgrade the cluster and all the clients at the same time, so being able to tolerate different versions of the same class across cluster members and clients is not only nice to have, but a necessity for many Coherence users. The issue is that when a process that has an older version of the class reads serialized data created from the newer version of the same class, it may encounter some attributes that it knows nothing about. Ideally, it should be able to ignore them and read the attributes it needs and knows about, instead of crashing, but that only solves part of the problem. If it ignores the unknown attributes completely, what will happen when it writes the same data back, by serializing an older version of the class that is only aware of some attributes? Unfortunately, the most likely answer is that it will lose the data it previously received but knows nothing about. Obviously, this is not a desirable scenario for a system that is intended for long-term data storage, so POF supports class evolution in a way that ensures that no data will be lost, regardless of how many versions of the same class are present across the various cluster and client processes, and regardless of which of those processes read or write the data. The support for class evolution has been in POF from the very beginning, via the Evolvable interface, but Portable Types remove some of the limitations and make the whole process significantly simpler. Both the class annotation ( @PortableType ) and the attribute annotations ( @Portable and related annotations) provide a way to specify versioning information necessary for class evolution. At the class level, whenever you modify a class by introducing a new attribute, you should increment the version property of the @PortableType annotation. At the same time, you should specify since attribute that matches the new class version number for any new class attribute. For example, to add age attribute to the Pet class, and color attribute to the Dog class, we would change the code above to: <markup lang=\"java\" >@PortableType(id = 1, version = 1) public class Pet { @Portable protected String name; @Portable(since = 1) protected int age; // constructors, accessors, etc. } @PortableType(id = 2, version = 1) public class Dog extends Pet { @Portable private String breed; @Portable(since = 1) private Color color; // constructors, accessors, etc. } Notice that both version and since properties are zero-based, which allows you to omit them completely in the initial implementation. It also means that for the first subsequent revision they should be set to 1 . Of course, those are just the defaults. You can certainly set the class and attribute version explicitly to any value even for the initial implementation, if you are so inclined. The only thing that matters is that you bump the version and set the since property to the latest version number whenever you make changes to the class in the future. For example, if in the future we decide to add height and weight attributes to the Pet class, we would simply increment the version to 2 and set the since property for the new attributes accordingly: <markup lang=\"java\" >@PortableType(id = 1, version = 2) public class Pet { @Portable protected String name; @Portable(since = 1) protected int age; @Portable(since = 2) protected int height; @Portable(since = 2) protected int weight; // constructors, accessors, etc. } Warning It may be obvious by now, but it&#8217;s probably worth calling out explicitly: class evolution allows you to add attributes to the new version of the class, but you should never remove existing attributes, as that will break serialization across class versions. You can certainly remove or deprecate attribute accessors from the class, but you should leave the field itself as-is, in order to preserve backwards compatibility of the serialized form. Along the same lines, you should avoid renaming the fields, as the default serialization order of fields is determined based on the alphabetical order of field names within a given class version (all fields with the same since value). ",
            "title": "Class Versioning and Evolution"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Annotating the classes is the first step in the implementation of Portable Types, but it is not sufficient on its own. In order to implement the necessary serialization logic, the classes also need to be instrumented at compile time. This is accomplished using the pof-maven-plugin , which should be configured in your POM file: <markup lang=\"xml\" >&lt;plugin&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;pof-maven-plugin&lt;/artifactId&gt; &lt;version&gt;20.12&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;instrument&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;instrument-tests&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument-tests&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; The configuration above will discover and instrument all project classes annotated with @PortableType annotation, including test classes. If you don&#8217;t need to instrument test classes you can omit the instrument-tests execution from the plugin configuration. The pof-maven-plugin uses Schema support to define the type system that contains all reachable portable types. This type system includes not only project classes that need to be instrumented, but also all portable types that exist in project dependencies. This is necessary because those dependent types may be used as attributes within the project classes, and need to be serialized appropriately. In some cases it may be necessary to expand the type system with the types that are not annotated with @PortableType annotation, and are not discovered automatically. This is typically the case when some of your portable types have enum values, or existing classes that implement PortableObject interface explicitly as attributes. You can add those types to the schema by creating a META-INF/schema.xml file and specifying them explicitly. For example, assuming the Color class from the code examples above is an enum type, you would need to create the following META-INF/schema.xml file to register it and allow pof-maven-plugin to instrument Dog class correctly: <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;schema xmlns=\"http://xmlns.oracle.com/coherence/schema\" xmlns:java=\"http://xmlns.oracle.com/coherence/schema/java\" external=\"true\"&gt; &lt;type name=\"Color\"&gt; &lt;java:type name=\"petstore.Color\"/&gt; &lt;/type&gt; &lt;/schema&gt; Once all these bits and pieces are in place, you can simply run your build as usual: <markup lang=\"text\" >$ mvn clean install You can verify that the classes were instrumented successfully by checking the Maven output log. You should see something similar to the following: <markup lang=\"text\" >[INFO] --- pof-maven-plugin:20.12:instrument (instrument) @ petstore --- [INFO] Running PortableTypeGenerator for classes in /projects/petstore/target/classes [INFO] Instrumenting type petstore.Pet [INFO] Instrumenting type petstore.Dog Once the classes are successfully instrumented, they are ready to be registered and used. ",
            "title": "Compile-time Instrumentation"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Portable Object Format is not a self-describing serialization format: it replaces platform-specific class names with integer-based type identifiers , so it needs a way of mapping those type identifiers back to the platform-specific classes. This enables portability across platforms, which was, as the name clearly says, the main objective of POF. To manage the mappings between the type identifiers and concrete types, POF uses com.tangosol.io.pof.PofContext : <markup lang=\"java\" >public interface PofContext extends Serializer { PofSerializer getPofSerializer(int nTypeId); int getUserTypeIdentifier(Object o); int getUserTypeIdentifier(Class&lt;?&gt; clz); int getUserTypeIdentifier(String sClass); String getClassName(int nTypeId); Class&lt;?&gt; getClass(int nTypeId); boolean isUserType(Object o); boolean isUserType(Class&lt;?&gt; clz); boolean isUserType(String sClass); } It is worth noting that PofContext extends com.tangosol.io.Serializer interface, which means that any PofContext implementation can be used wherever Coherence expects a Serializer to be specified: within cache services as a storage-level serializer for data classes, as a transport-level serializer between thin clients and the proxy servers, etc. The PofContext performs the actual serialization by delegating to the appropriate PofSerializer , which is obtained via the PofContext.getPofSerializer method, based on a type identifier. There are several built-in implementations of PofContext . The SimplePofContext allows you to programmatically register type mappings by providing all the metadata needed for serialization, such as type identifier, class, and the PofSerializer to use: <markup lang=\"java\" >SimplePofContext ctx = new SimplePofContext(); ctx.registerUserType(1, Pet.class, new PortableTypeSerializer&lt;&gt;(1, Pet.class)); ctx.registerUserType(2, Dog.class, new PortableTypeSerializer&lt;&gt;(2, Dog.class)); ctx.registerUserType(3, Color.class, new EnumPofSerializer()); Notice that a lot of this information is somewhat repetitive and unnecessary when working with portable types, as all the metadata you need can be obtained from the class itself or the @PortableType annotation. Because of that, SimplePofContext also provides several convenience methods, specifically for portable types: <markup lang=\"java\" >ctx.registerPortableType(Pet.class); ctx.registerPortableType(Dog.class); Or even simpler: <markup lang=\"java\" >ctx.registerPortableTypes(Pet.class, Dog.class); While the SimplePofContext is useful for testing and quick prototyping, a PofContext implementation that is much more widely used within Coherence applications is ConfigurablePofContext . The ConfigurablePofContext allows you to provide type mappings via an external XML file: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;user-type&gt; &lt;type-id&gt;1&lt;/type-id&gt; &lt;class-name&gt;petstore.Pet&lt;/class-name&gt; &lt;/user-type&gt; &lt;user-type&gt; &lt;type-id&gt;2&lt;/type-id&gt; &lt;class-name&gt;petstore.Dog&lt;/class-name&gt; &lt;/user-type&gt; &lt;user-type&gt; &lt;type-id&gt;3&lt;/type-id&gt; &lt;class-name&gt;petstore.Color&lt;/class-name&gt; &lt;serializer&gt; &lt;class-name&gt;com.tangosol.io.pof.EnumPofSerializer&lt;/class-name&gt; &lt;/serializer&gt; &lt;/user-type&gt; &lt;/user-type-list&gt; &lt;/pof-config&gt; You may notice that we didn&#8217;t have to specify serializer explicitly for Pet and Dog classes. This is because ConfigurablePofContext has the logic to determine which of the built-in PofSerializer implementations to use depending on the interfaces implemented by, or the annotations present on the specified class. In this case, it will automatically use PortableTypeSerializer because the classes have @PortableType annotation. However, we can make the configuration even simpler by enabling portable type discovery: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;user-type&gt; &lt;type-id&gt;3&lt;/type-id&gt; &lt;class-name&gt;petstore.Color&lt;/class-name&gt; &lt;serializer&gt; &lt;class-name&gt;com.tangosol.io.pof.EnumPofSerializer&lt;/class-name&gt; &lt;/serializer&gt; &lt;/user-type&gt; &lt;/user-type-list&gt; &lt;enable-type-discovery&gt;true&lt;/enable-type-discovery&gt; &lt;/pof-config&gt; Once you set the enable-type-discovery flag to true , the ConfigurablePofContext will discover all the classes annotated with @PortableType and register them automatically, based on the annotation metadata. If we didn&#8217;t have the Color enum that has to be registered explicitly, we could even omit the configuration file completely, as the default pof-config.xml file that is built into Coherence looks like this: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;!-- by default just include coherence POF user types --&gt; &lt;include&gt;coherence-pof-config.xml&lt;/include&gt; &lt;/user-type-list&gt; &lt;enable-type-discovery&gt;true&lt;/enable-type-discovery&gt; &lt;/pof-config&gt; Note The portable type discovery feature depends on the availability of a Jandex index within the modules that provide portable types that need to be registered. Make sure that you configure Jandex Maven Plugin to index classes in your modules at build time: <markup lang=\"xml\" >&lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ",
            "title": "Registration and Discovery"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Once you have annotated, instrumented and registered portable types as described in the sections above, you can use them with Coherence just as easily as you would use plain Java Serializable classes, by configuring Coherence services to use pof serializer instead of the default java serializer. However, there is still one problem: serialization code is implemented by the pof-maven-plugin at compile-time, and only if you run Maven build, which can make it a bit cumbersome to run unit and integration tests within your IDE. In order to solve that problem, we have implemented IDE plugins for IntelliJ IDEA and Eclipse, which can instrument your classes during incremental or full compilation performed by your IDE. This allows you to test both the serialization of your classes and the code that depends on it without having to run Maven build or leave your IDE. Please follow the documentation for the Coherence IntelliJ Plugin or Coherence Eclipse Plugin for detailed instructions on how to install and use the plugin for your favorite IDE. Note We&#8217;ve used 1, 2, and 3 as type identifiers in the code and configuration examples above for simplicity, but it is worth noting that Coherence reserves type identifiers from 0 to 999 for internal use. That means that you should only use type identifiers of 1000 or higher for your own classes. ",
            "title": "IDE Support"
        },
        {
            "location": "/docs/core/04_portable_types",
            "text": " Portable Object Format (POF) was first introduced in Coherence 3.2 (2006), as a way to serialize classes in a platform and language independent format, and is the only serialization format supported by the legacy non-Java Extend clients, such as .NET and C++ Extend client implementations. As soon as it was released, POF became the preferred serialization format even for customers writing pure Java applications, for several reasons: It is significantly faster than other supported serialization formats, such as Java serialization and ExternalizableLite . It is significantly more compact that other supported serialization formats, allowing you to store more data in a cluster of a given size, and to move less data over the wire. It supports seamless evolution of data classes, allowing you to upgrade various parts of the application (both storage members and clients) independently of one another, without the risk of losing data in the process. Over the years POF remained largely unchanged, even though it did receive a number of additional features that simplified its use: POF Reflection was introduced in Coherence 3.5 (2009), allowing users to extract individual attributes from the POF stream via PofNavigator . POF Annotations were introduced in Coherence 3.7.1 (2011), as a way to eliminate the need for the manual implementation of the serialization-related code. Unfortunately, the latter fell a bit short. The implementation was heavily dependent on Java reflection, which sacrificed some performance benefits of POF. More importantly, they provide no support for class evolution, thus sacrificing another important POF benefit. As such, POF Annotations were deemed somewhat inadequate, and we started working on their replacement in 2013. Some supporting features, such as schema support , were included in Coherence 12.2.1 (2015) and 14.1.1 (2020), and the remaining work was completed and released as part of the Coherence CE 20.12 release and will be available in the next commercial release. Features and Benefits Portable Types provide a way to add support for POF serialization to your classes via annotations and without the need to implement serialization code by hand, just like POF Annotations did. However, unlike POF Annotations, Portable Types: Implement serialization code at compile-time using byte code instrumentation, and do not rely on Java reflection at runtime at all. This makes them just as fast, but less error-prone, as manually implemented serialization code. Support, but do not require explicit registration via POF config file, as all the metadata required for POF type registration, such as type identifier, and the serializer class to use, are already available in the @PortableType annotation. Fully support class evolution. As a matter of fact, Portable Types provide a better and more complete evolution support than if you implemented Evolvable interface by hand. One of the limitations of Evolvable is that it only supports evolution of the leaf classes in the class hierarchy. Portable Types do not have this limitation, and allow you not only to evolve any class in the hierarchy, but also to evolve the class hierarchy itself, by adding new classes to any level of the class hierarchy. When we first introduced POF back in 2006, it was never the goal to require manual implementation of the serialization code&#8201;&#8212;&#8201;we always wanted to provide the tooling that would do the heavy lifting and allow users to simply express their intent via annotations. It may have taken us almost 15 years, but we feel that with the release of Portable Types, we are finally there. Usage Basics There are only two basic requirements for Portable Types: The class must be annotated with @PortableType annotation, and The fields that should be serialized must be annotated with @Portable or one of related annotations ( @PortableDate , @PortableArray , @PortableSet , @PortableList , or @PortableMap ) <markup lang=\"java\" >@PortableType(id = 1) public class Pet { @Portable protected String name; // constructors, accessors, etc. } @PortableType(id = 2) public class Dog extends Pet { @Portable private String breed; // constructors, accessors, etc. } Additional attribute-level annotations allow you to control certain serialization behaviors that are specific to the type of the attribute. For example, @PortableDate allows you to control whether you want to serialize date, time, or both when serializing java.util.Date instances (via mode property), and whether time zone information should be included (via includeTimezone property). If you are using Java 8 (or later) java.time classes, that information can be derived from the class itself, so you can (and should) simply use @Portable annotation instead. For example, LocalTime will be serialized as time only, with no time zone information, while the OffsetDateTime will be serialized as both date and time, with time zone information. Similarly, when serializing arrays, collections and maps, POF allows you to use uniform encoding , where the element type (or key and/or value type, in case of maps) is written into the POF stream only once, instead of once for each element of the collection, resulting in a more compact serialized form. <markup lang=\"java\" >public class MyClass { @PortableArray(elementClass = String.class) private String[] m_stringArray; @PortableSet(elementClass = String.class, clazz = LinkedHashSet.class) private Set&lt;String&gt; m_setOfStrings; @PortableList(elementClass = String.class) private List&lt;String&gt; m_listOfStrings; @PortableMap(keyClass = Integer.class, valueClass = String.class, clazz = TreeMap.class) private Map&lt;Integer, String&gt; m_uniformMap; } As you can see from the examples above, these annotations also allow you to specify the concrete class that should be created during deserialization for a given attribute. If the clazz property is not specified, HashSet will be used as a default set type, ArrayList as a default list type, and HashMap as a default map type. Class Versioning and Evolution Coherence is a distributed system, and there is no guarantee that every cluster member, and every client process that connects to the cluster, will have the same version of each and every class. As a matter of fact, for systems that use rolling upgrades in order to avoid any downtime, it is pretty much guaranteed that they won&#8217;t! It is also neither safe nor practical for most Coherence customers to upgrade the cluster and all the clients at the same time, so being able to tolerate different versions of the same class across cluster members and clients is not only nice to have, but a necessity for many Coherence users. The issue is that when a process that has an older version of the class reads serialized data created from the newer version of the same class, it may encounter some attributes that it knows nothing about. Ideally, it should be able to ignore them and read the attributes it needs and knows about, instead of crashing, but that only solves part of the problem. If it ignores the unknown attributes completely, what will happen when it writes the same data back, by serializing an older version of the class that is only aware of some attributes? Unfortunately, the most likely answer is that it will lose the data it previously received but knows nothing about. Obviously, this is not a desirable scenario for a system that is intended for long-term data storage, so POF supports class evolution in a way that ensures that no data will be lost, regardless of how many versions of the same class are present across the various cluster and client processes, and regardless of which of those processes read or write the data. The support for class evolution has been in POF from the very beginning, via the Evolvable interface, but Portable Types remove some of the limitations and make the whole process significantly simpler. Both the class annotation ( @PortableType ) and the attribute annotations ( @Portable and related annotations) provide a way to specify versioning information necessary for class evolution. At the class level, whenever you modify a class by introducing a new attribute, you should increment the version property of the @PortableType annotation. At the same time, you should specify since attribute that matches the new class version number for any new class attribute. For example, to add age attribute to the Pet class, and color attribute to the Dog class, we would change the code above to: <markup lang=\"java\" >@PortableType(id = 1, version = 1) public class Pet { @Portable protected String name; @Portable(since = 1) protected int age; // constructors, accessors, etc. } @PortableType(id = 2, version = 1) public class Dog extends Pet { @Portable private String breed; @Portable(since = 1) private Color color; // constructors, accessors, etc. } Notice that both version and since properties are zero-based, which allows you to omit them completely in the initial implementation. It also means that for the first subsequent revision they should be set to 1 . Of course, those are just the defaults. You can certainly set the class and attribute version explicitly to any value even for the initial implementation, if you are so inclined. The only thing that matters is that you bump the version and set the since property to the latest version number whenever you make changes to the class in the future. For example, if in the future we decide to add height and weight attributes to the Pet class, we would simply increment the version to 2 and set the since property for the new attributes accordingly: <markup lang=\"java\" >@PortableType(id = 1, version = 2) public class Pet { @Portable protected String name; @Portable(since = 1) protected int age; @Portable(since = 2) protected int height; @Portable(since = 2) protected int weight; // constructors, accessors, etc. } Warning It may be obvious by now, but it&#8217;s probably worth calling out explicitly: class evolution allows you to add attributes to the new version of the class, but you should never remove existing attributes, as that will break serialization across class versions. You can certainly remove or deprecate attribute accessors from the class, but you should leave the field itself as-is, in order to preserve backwards compatibility of the serialized form. Along the same lines, you should avoid renaming the fields, as the default serialization order of fields is determined based on the alphabetical order of field names within a given class version (all fields with the same since value). Compile-time Instrumentation Annotating the classes is the first step in the implementation of Portable Types, but it is not sufficient on its own. In order to implement the necessary serialization logic, the classes also need to be instrumented at compile time. This is accomplished using the pof-maven-plugin , which should be configured in your POM file: <markup lang=\"xml\" >&lt;plugin&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;pof-maven-plugin&lt;/artifactId&gt; &lt;version&gt;20.12&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;instrument&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;instrument-tests&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument-tests&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; The configuration above will discover and instrument all project classes annotated with @PortableType annotation, including test classes. If you don&#8217;t need to instrument test classes you can omit the instrument-tests execution from the plugin configuration. The pof-maven-plugin uses Schema support to define the type system that contains all reachable portable types. This type system includes not only project classes that need to be instrumented, but also all portable types that exist in project dependencies. This is necessary because those dependent types may be used as attributes within the project classes, and need to be serialized appropriately. In some cases it may be necessary to expand the type system with the types that are not annotated with @PortableType annotation, and are not discovered automatically. This is typically the case when some of your portable types have enum values, or existing classes that implement PortableObject interface explicitly as attributes. You can add those types to the schema by creating a META-INF/schema.xml file and specifying them explicitly. For example, assuming the Color class from the code examples above is an enum type, you would need to create the following META-INF/schema.xml file to register it and allow pof-maven-plugin to instrument Dog class correctly: <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;schema xmlns=\"http://xmlns.oracle.com/coherence/schema\" xmlns:java=\"http://xmlns.oracle.com/coherence/schema/java\" external=\"true\"&gt; &lt;type name=\"Color\"&gt; &lt;java:type name=\"petstore.Color\"/&gt; &lt;/type&gt; &lt;/schema&gt; Once all these bits and pieces are in place, you can simply run your build as usual: <markup lang=\"text\" >$ mvn clean install You can verify that the classes were instrumented successfully by checking the Maven output log. You should see something similar to the following: <markup lang=\"text\" >[INFO] --- pof-maven-plugin:20.12:instrument (instrument) @ petstore --- [INFO] Running PortableTypeGenerator for classes in /projects/petstore/target/classes [INFO] Instrumenting type petstore.Pet [INFO] Instrumenting type petstore.Dog Once the classes are successfully instrumented, they are ready to be registered and used. Registration and Discovery Portable Object Format is not a self-describing serialization format: it replaces platform-specific class names with integer-based type identifiers , so it needs a way of mapping those type identifiers back to the platform-specific classes. This enables portability across platforms, which was, as the name clearly says, the main objective of POF. To manage the mappings between the type identifiers and concrete types, POF uses com.tangosol.io.pof.PofContext : <markup lang=\"java\" >public interface PofContext extends Serializer { PofSerializer getPofSerializer(int nTypeId); int getUserTypeIdentifier(Object o); int getUserTypeIdentifier(Class&lt;?&gt; clz); int getUserTypeIdentifier(String sClass); String getClassName(int nTypeId); Class&lt;?&gt; getClass(int nTypeId); boolean isUserType(Object o); boolean isUserType(Class&lt;?&gt; clz); boolean isUserType(String sClass); } It is worth noting that PofContext extends com.tangosol.io.Serializer interface, which means that any PofContext implementation can be used wherever Coherence expects a Serializer to be specified: within cache services as a storage-level serializer for data classes, as a transport-level serializer between thin clients and the proxy servers, etc. The PofContext performs the actual serialization by delegating to the appropriate PofSerializer , which is obtained via the PofContext.getPofSerializer method, based on a type identifier. There are several built-in implementations of PofContext . The SimplePofContext allows you to programmatically register type mappings by providing all the metadata needed for serialization, such as type identifier, class, and the PofSerializer to use: <markup lang=\"java\" >SimplePofContext ctx = new SimplePofContext(); ctx.registerUserType(1, Pet.class, new PortableTypeSerializer&lt;&gt;(1, Pet.class)); ctx.registerUserType(2, Dog.class, new PortableTypeSerializer&lt;&gt;(2, Dog.class)); ctx.registerUserType(3, Color.class, new EnumPofSerializer()); Notice that a lot of this information is somewhat repetitive and unnecessary when working with portable types, as all the metadata you need can be obtained from the class itself or the @PortableType annotation. Because of that, SimplePofContext also provides several convenience methods, specifically for portable types: <markup lang=\"java\" >ctx.registerPortableType(Pet.class); ctx.registerPortableType(Dog.class); Or even simpler: <markup lang=\"java\" >ctx.registerPortableTypes(Pet.class, Dog.class); While the SimplePofContext is useful for testing and quick prototyping, a PofContext implementation that is much more widely used within Coherence applications is ConfigurablePofContext . The ConfigurablePofContext allows you to provide type mappings via an external XML file: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;user-type&gt; &lt;type-id&gt;1&lt;/type-id&gt; &lt;class-name&gt;petstore.Pet&lt;/class-name&gt; &lt;/user-type&gt; &lt;user-type&gt; &lt;type-id&gt;2&lt;/type-id&gt; &lt;class-name&gt;petstore.Dog&lt;/class-name&gt; &lt;/user-type&gt; &lt;user-type&gt; &lt;type-id&gt;3&lt;/type-id&gt; &lt;class-name&gt;petstore.Color&lt;/class-name&gt; &lt;serializer&gt; &lt;class-name&gt;com.tangosol.io.pof.EnumPofSerializer&lt;/class-name&gt; &lt;/serializer&gt; &lt;/user-type&gt; &lt;/user-type-list&gt; &lt;/pof-config&gt; You may notice that we didn&#8217;t have to specify serializer explicitly for Pet and Dog classes. This is because ConfigurablePofContext has the logic to determine which of the built-in PofSerializer implementations to use depending on the interfaces implemented by, or the annotations present on the specified class. In this case, it will automatically use PortableTypeSerializer because the classes have @PortableType annotation. However, we can make the configuration even simpler by enabling portable type discovery: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;user-type&gt; &lt;type-id&gt;3&lt;/type-id&gt; &lt;class-name&gt;petstore.Color&lt;/class-name&gt; &lt;serializer&gt; &lt;class-name&gt;com.tangosol.io.pof.EnumPofSerializer&lt;/class-name&gt; &lt;/serializer&gt; &lt;/user-type&gt; &lt;/user-type-list&gt; &lt;enable-type-discovery&gt;true&lt;/enable-type-discovery&gt; &lt;/pof-config&gt; Once you set the enable-type-discovery flag to true , the ConfigurablePofContext will discover all the classes annotated with @PortableType and register them automatically, based on the annotation metadata. If we didn&#8217;t have the Color enum that has to be registered explicitly, we could even omit the configuration file completely, as the default pof-config.xml file that is built into Coherence looks like this: <markup lang=\"xml\" >&lt;pof-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-pof-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd\"&gt; &lt;user-type-list&gt; &lt;!-- by default just include coherence POF user types --&gt; &lt;include&gt;coherence-pof-config.xml&lt;/include&gt; &lt;/user-type-list&gt; &lt;enable-type-discovery&gt;true&lt;/enable-type-discovery&gt; &lt;/pof-config&gt; Note The portable type discovery feature depends on the availability of a Jandex index within the modules that provide portable types that need to be registered. Make sure that you configure Jandex Maven Plugin to index classes in your modules at build time: <markup lang=\"xml\" >&lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; IDE Support Once you have annotated, instrumented and registered portable types as described in the sections above, you can use them with Coherence just as easily as you would use plain Java Serializable classes, by configuring Coherence services to use pof serializer instead of the default java serializer. However, there is still one problem: serialization code is implemented by the pof-maven-plugin at compile-time, and only if you run Maven build, which can make it a bit cumbersome to run unit and integration tests within your IDE. In order to solve that problem, we have implemented IDE plugins for IntelliJ IDEA and Eclipse, which can instrument your classes during incremental or full compilation performed by your IDE. This allows you to test both the serialization of your classes and the code that depends on it without having to run Maven build or leave your IDE. Please follow the documentation for the Coherence IntelliJ Plugin or Coherence Eclipse Plugin for detailed instructions on how to install and use the plugin for your favorite IDE. Note We&#8217;ve used 1, 2, and 3 as type identifiers in the code and configuration examples above for simplicity, but it is worth noting that Coherence reserves type identifiers from 0 to 999 for internal use. That means that you should only use type identifiers of 1000 or higher for your own classes. ",
            "title": "Portable Types"
        },
        {
            "location": "/coherence-mp/README",
            "text": " Coherence provides a number of additional modules that provide support for different Microprofile APIs. Microprofile Config Using Coherence as a Microprofile config source. Microprofile Metrics Configure Coherence to publish metrics via the Microprofile metrics API. ",
            "title": "Coherence MP"
        },
        {
            "location": "/docs/README",
            "text": " To build the docs, run the following Maven command from the top-level prj/ directory: <markup lang=\"shell\" >mvn clean install -DskipTests -P docs -pl docs ",
            "title": "Build the Docs"
        },
        {
            "location": "/docs/README",
            "text": " To view the documentation to see what it looks like after building run the following command from the top-level prj/ directory: <markup lang=\"shell\" >mvn exec:exec -P docs -pl docs Docs can be viewd at http://localhost:8080 This requires Python to be installed and runs a small Python http server from the directory where the docs have been built to. ",
            "title": "View the Docs"
        },
        {
            "location": "/docs/README",
            "text": " This is the module that builds the Coherence documentation. The module is not part of the default build and must be built separately. Build the Docs To build the docs, run the following Maven command from the top-level prj/ directory: <markup lang=\"shell\" >mvn clean install -DskipTests -P docs -pl docs View the Docs To view the documentation to see what it looks like after building run the following command from the top-level prj/ directory: <markup lang=\"shell\" >mvn exec:exec -P docs -pl docs Docs can be viewd at http://localhost:8080 This requires Python to be installed and runs a small Python http server from the directory where the docs have been built to. ",
            "title": "Coherence Documentation Module"
        },
        {
            "location": "/docs/README",
            "text": " When putting version numbers in .adoc files, we use attribute substitutions. Attributes are set in the sitegen.yaml file, for example engine: asciidoctor: images-dir: \"docs/images\" libraries: - \"asciidoctor-diagram\" attributes: plantumlconfig: \"_plantuml-config.txt\" coherence-maven-group-id: \"${coherence.group.id}\" version-coherence: \"${revision}\" version-commercial-docs: \"14.1.1.0\" version-helidon: \"${helidon.version}\" The format of an attribute is name followed by a colon, and the attribute value in quotes, so above the value of the version-commercial-docs attribute is 14.1.1.0 . Attributes can be taken from Maven build properties by using the normal Maven property replacement string as the value. For example the version-coherence attribute&#8217;s value will be the Maven revision property value. In the .adoc files the attributes are then substituted by putting the attribute name in curly brackets. For example: The current commercial Coherence version is 14.1.1.0. would become The current commercial Coherence version is 14.1.1.0. ",
            "title": "Version Numbers"
        },
        {
            "location": "/docs/about/01_overview",
            "text": " Note The documentation on this site covers new features and improvements that are currently only available in the open source Coherence Community Edition (CE). For complete documentation covering all the features that are available both in the latest commercial editions (Enterprise and Grid Edition) and the Community Edition, please refer to the Official Documentation . Coherence is scalable, fault-tolerant, cloud-ready, distributed platform for building grid-based applications and reliably storing data. The product is used at scale, for both compute and raw storage, in a vast array of industries such as critical financial trading systems, high performance telecommunication products, and eCommerce applications. Typically, these deployments do not tolerate any downtime and Coherence is chosen due its novel features in death detection, application data evolvability, and the robust, battle-hardened core of the product that enables it to be seamlessly deployed and adapted within any ecosystem. At a high level, Coherence provides an implementation of the familiar Map&lt;K,V&gt; interface but rather than storing the associated data in the local process, it is partitioned (or sharded) across a number of designated remote nodes. This partitioning enables applications to not only distribute (and therefore scale) their storage across multiple processes, machines, racks, and data centers, but also to perform grid-based processing to truly harness the CPU resources of the machines. The Coherence interface NamedMap&lt;K,V&gt; (an extension of Map&lt;K,V&gt; provides methods to query, aggregate (map/reduce style), and compute (send functions to storage nodes for locally executed mutations) the data set. These capabilities, in addition to numerous other features, enable Coherence to be used as a framework to write robust, distributed applications. ",
            "title": "Overview"
        },
        {
            "location": "/docs/about/01_overview",
            "text": " explore Coherence What is Oracle Coherence? fa-rocket Quick Start A quick-start guide to using Coherence. import_contacts Docs Oracle Coherence commercial edition product documentation. library_books API Docs Browse the Coherence CE API Docs. ",
            "title": "Get Going"
        },
        {
            "location": "/docs/about/01_overview",
            "text": " fa-cubes Core Coherence Core Improvements. extension CDI Coherence CDI extensions. fa-cogs Microprofile Coherence Microprofile support. settings_ethernet gRPC Coherence gRPC server and client. ",
            "title": "New Features"
        },
        {
            "location": "/docs/about/01_overview",
            "text": " fa-plug Plugins Build tool plugins to aid Coherence application development. fa-th Container Images Example Coherence OCI container (Docker) images. ",
            "title": "Tools"
        },
        {
            "location": "/docs/about/02_introduction",
            "text": " First and foremost, Coherence provides a fundamental service that is responsible for all facets of clustering and is a common denominator / building block for all other Coherence services. This service, referred to as 'service 0' internally, ensures the mesh of members is maintained and responsive, taking action to collaboratively evict, shun, or in some cases voluntarily depart the cluster when deemed necessary. As members join and leave the cluster, other Coherence services are notified thus allows those services to react accordingly. This part of the Coherence product has been in production for 10+ years, being the subject of some extensive and imaginative testing. While it has been discussed here it certainly is not something that customers, generally, interact with directly but is valuable to be aware of. Coherence services build on top of the clustering service, with the key implementations to be aware of are PartitionedService, InvocationService, and ProxyService. In the majority of cases customers will deal with caches; a cache will be represented by an implementation of NamedCache&lt;K,V&gt; . Cache is an unfortunate name, as many Coherence customers use Coherence as a system-of-record rather than a lossy store of data. A cache is hosted by a service, generally the PartitionedService, and is the entry point to storing, retrieving, aggregating, querying, and streaming data. There are a number of features that caches provide: Fundamental key-based access : get/put getAll/putAll Client-side and storage-side events MapListeners to asynchronously notify clients of changes to data EventInterceptors (either sync or async) to be notified storage level events, including mutations, partition transfer, failover, etc NearCaches - locally cached data based on previous requests with local content invalidated upon changes in storage tier ViewCaches - locally stored view of remote data that can be a subset based on a predicate and is kept in sync real time Queries - distributed, parallel query evaluation to return matching key, values or entries with potential to optimize performance with indices Aggregations - a map/reduce style aggregation where data is aggregated in parallel on all storage nodes and results streamed back to the client for aggregation of those results to produce a final result Data local processing - an ability to send a function to the relevant storage node to execute processing logic for the appropriate entries with exclusive access Partition local transactions - an ability to perform scalable transactions by associating data (thus being on the same partition) and manipulating other entries on the same partition potentially across caches Non-blocking / async NamedCache API C&#43;&#43; and .NET clients - access the same NamedCache API from either C&#43;&#43; or .NET Portable Object Format - optimized serialization format, with the ability to navigate the serialized form for optimized queries, aggregations, or data processing Integration with Databases - Database &amp; third party data integration with CacheStores including both synchronous or asynchronous writes CohQL - ansi-style query language with a console for adhoc queries Topics - distributed topics implementation offering pub/sub messaging with the storage capacity the cluster and parallelizable subscribers There are also a number of non-functional features that Coherence provides: Rock solid clustering - highly tuned and robust clustering stack that allows Coherence to scale to thousands of members in a cluster with thousands of partitions and terabytes of data being accessed, mutated, queried and aggregated concurrently Safety first - resilient data management that ensures backup copies are on distinct machines, racks, or sites and the ability to maintain multiple backups 24/7 Availability - zero down time with rolling redeploy of cluster members to upgrade application or product versions Backwards and forwards compatibility of product upgrades, including major versions Persistent Caches - with the ability to use local file system persistence (thus avoid extra network hops) and leverage Coherence consensus protocols to perform distributed disk recovery when appropriate Distributed State Snapshot - ability to perform distributed point-in-time snapshot of cluster state, and recover snapshot in this or a different cluster (leverages persistence feature) Lossy redundancy - ability to reduce the redundancy guarantee by making backups and/or persistence asynchronous from a client perspective Single Mangement View - provides insight into the cluster with a single JMX server that provides a view of all members of the cluster Management over REST - all JMX data and operations can be performed over REST, including cluster wide thread dumps and heapdumps Non-cluster Access - access to the cluster from the outside via proxies, for distant (high latency) clients and for non-java languages such as C&#43;&#43; and .NET Kubernetes friendly - seamlessly and safely deploy applications to k8s with our own operator ",
            "title": "Introduction"
        },
        {
            "location": "/docs/about/02_introduction",
            "text": " Coherence Community Edition does not include the following Oracle Coherence commercial edition functionality Management of Coherence via the Oracle WebLogic Management Framework WebLogic Server Multi-tenancy support Deployment of Grid Archives (GARs) HTTP session management for application servers (Coherence*Web) GoldenGate HotCache TopLink-based CacheLoaders and CacheStores Elastic Data Federation and WAN (wide area network) support Transaction Framework CommonJ work manager ",
            "title": "Coherence Community Edition Disabled and Excluded Functionality"
        },
        {
            "location": "/plugins/maven/pof-maven-plugin/README",
            "text": " The POF Maven Plugin provides automated instrumentation of classes with the @PortableType annotation to generate consistent (and correct) implementations of Evolvable POF serialization methods. It is a far from a trivial exercise to manually write serialization methods that support serializing inheritance hierarchies that support the Evolvable concept. However, with static type analysis these methods can be deterministically generated. This allows developers to focus on business logic rather than implementing boilerplate code for the above-mentioned methods. Please see Portable Types documentation for more information and detailed instructions on Portable Types creation and usage. ",
            "title": "POF Maven Plugin"
        },
        {
            "location": "/plugins/maven/pof-maven-plugin/README",
            "text": " In order to use the POF Maven Plugin, you need to declare it as a plugin dependency in your pom.xml : <markup lang=\"xml\" > &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;pof-maven-plugin&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;instrument&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;instrument-tests&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;instrument-tests&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; An example Person class (below) when processed with the plugin is below results in the bytecode shown below. <markup lang=\"java\" >@PortableType(id=1000) public class Person { public Person() { } public Person(int id, String name, Address address) { super(); this.id = id; this.name = name; this.address = address; } int id; String name; Address address; // getters and setters omitted for brevity } Generated bytecode: <markup lang=\"bash\" >$ javap Person.class Compiled from \"Person.java\" public class demo.Person implements com.tangosol.io.pof.PortableObject,com.tangosol.io.pof.EvolvableObject { int id; java.lang.String name; demo.Address address; public demo.Person(); public demo.Person(int, java.lang.String, demo.Address); public int getId(); public void setId(int); public java.lang.String getName(); public void setName(java.lang.String); public demo.Address getAddress(); public void setAddress(demo.Address); public java.lang.String toString(); public int hashCode(); public boolean equals(java.lang.Object); public void readExternal(com.tangosol.io.pof.PofReader) throws java.io.IOException; public void writeExternal(com.tangosol.io.pof.PofWriter) throws java.io.IOException; public com.tangosol.io.Evolvable getEvolvable(int); public com.tangosol.io.pof.EvolvableHolder getEvolvableHolder(); } Additional methods generated by Coherence POF plugin. ",
            "title": "Usage"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " Java - jdk8 or higher Maven - 3.6.3 or higher ",
            "title": "Prerequisites"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " As Coherence is generally embedded into an application by using Coherence APIs, the natural place to consume this dependency is from Maven: <markup lang=\"xml\" title=\"pom.xml\" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; You can also get Coherence from the official Docker image . For other language clients, use ( C&#43;&#43; and .NET ), and for the non-community edition, see Oracle Technology Network . ",
            "title": "How to Get Coherence Community Edition"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " Prerequisites Java - jdk8 or higher Maven - 3.6.3 or higher How to Get Coherence Community Edition As Coherence is generally embedded into an application by using Coherence APIs, the natural place to consume this dependency is from Maven: <markup lang=\"xml\" title=\"pom.xml\" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; You can also get Coherence from the official Docker image . For other language clients, use ( C&#43;&#43; and .NET ), and for the non-community edition, see Oracle Technology Network . ",
            "title": "Quick Start"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " To run a CohQL console: <markup lang=\"shell\" >$&gt; mvn -DgroupId=com.oracle.coherence.ce -DartifactId=coherence -Dversion=20.12.1 dependency:get $&gt; export COH_JAR=~/.m2/repository/com/oracle/coherence/ce/coherence/20.12.1/coherence-20.12.1.jar $&gt; java -jar $COH_JAR &amp; $&gt; java -cp $COH_JAR com.tangosol.coherence.dslquery.QueryPlus CohQL&gt; select * from welcomes CohQL&gt; insert into welcomes key 'english' value 'Hello' CohQL&gt; insert into welcomes key 'spanish' value 'Hola' CohQL&gt; insert into welcomes key 'french' value 'Bonjour' CohQL&gt; select key(), value() from welcomes Results [\"french\", \"Bonjour\"] [\"english\", \"Hello\"] [\"spanish\", \"Hola\"] CohQL&gt; bye $&gt; java -cp $COH_JAR com.tangosol.coherence.dslquery.QueryPlus CohQL&gt; select key(), value() from welcomes Results [\"french\", \"Bonjour\"] [\"english\", \"Hello\"] [\"spanish\", \"Hola\"] CohQL&gt; bye $&gt; kill %1 ",
            "title": " CohQL Console"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " To run the Coherence console: <markup lang=\"shell\" >$&gt; mvn -DgroupId=com.oracle.coherence.ce -DartifactId=coherence -Dversion=20.12.1 dependency:get $&gt; export COH_JAR=~/.m2/repository/com/oracle/coherence/ce/coherence/20.12.1/coherence-20.12.1.jar $&gt; java -jar $COH_JAR &amp; $&gt; java -cp $COH_JAR com.tangosol.net.CacheFactory Map (?): cache welcomes Map (welcomes): get english null Map (welcomes): put english Hello null Map (welcomes): put spanish Hola null Map (welcomes): put french Bonjour null Map (welcomes): get english Hello Map (welcomes): list french = Bonjour spanish = Hola english = Hello Map (welcomes): bye $&gt; java -cp $COH_JAR com.tangosol.net.CacheFactory Map (?): cache welcomes Map (welcomes): list french = Bonjour spanish = Hola english = Hello Map (welcomes): bye $&gt; kill %1 ",
            "title": " Coherence Console"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " The following example illustrates the procedure to start a storage enabled Coherence Server, followed by a storage disabled Coherence Console. Using the console, data is inserted, retrieved, and then the console is terminated. The console is restarted and data is once again retrieved to illustrate the permanence of the data. This example uses the out-of-the-box cache configuration and therefore explicitly specifying the console is storage disabled is unnecessary. Coherence cluster members discover each other via one of two mechanisms; multicast (default) or Well Known Addressing (deterministic broadcast). If your system does not support multicast, enable WKA by specifying -Dcoherence.wka=localhost for both processes started in the following console examples. CohQL Console To run a CohQL console: <markup lang=\"shell\" >$&gt; mvn -DgroupId=com.oracle.coherence.ce -DartifactId=coherence -Dversion=20.12.1 dependency:get $&gt; export COH_JAR=~/.m2/repository/com/oracle/coherence/ce/coherence/20.12.1/coherence-20.12.1.jar $&gt; java -jar $COH_JAR &amp; $&gt; java -cp $COH_JAR com.tangosol.coherence.dslquery.QueryPlus CohQL&gt; select * from welcomes CohQL&gt; insert into welcomes key 'english' value 'Hello' CohQL&gt; insert into welcomes key 'spanish' value 'Hola' CohQL&gt; insert into welcomes key 'french' value 'Bonjour' CohQL&gt; select key(), value() from welcomes Results [\"french\", \"Bonjour\"] [\"english\", \"Hello\"] [\"spanish\", \"Hola\"] CohQL&gt; bye $&gt; java -cp $COH_JAR com.tangosol.coherence.dslquery.QueryPlus CohQL&gt; select key(), value() from welcomes Results [\"french\", \"Bonjour\"] [\"english\", \"Hello\"] [\"spanish\", \"Hola\"] CohQL&gt; bye $&gt; kill %1 Coherence Console To run the Coherence console: <markup lang=\"shell\" >$&gt; mvn -DgroupId=com.oracle.coherence.ce -DartifactId=coherence -Dversion=20.12.1 dependency:get $&gt; export COH_JAR=~/.m2/repository/com/oracle/coherence/ce/coherence/20.12.1/coherence-20.12.1.jar $&gt; java -jar $COH_JAR &amp; $&gt; java -cp $COH_JAR com.tangosol.net.CacheFactory Map (?): cache welcomes Map (welcomes): get english null Map (welcomes): put english Hello null Map (welcomes): put spanish Hola null Map (welcomes): put french Bonjour null Map (welcomes): get english Hello Map (welcomes): list french = Bonjour spanish = Hola english = Hello Map (welcomes): bye $&gt; java -cp $COH_JAR com.tangosol.net.CacheFactory Map (?): cache welcomes Map (welcomes): list french = Bonjour spanish = Hola english = Hello Map (welcomes): bye $&gt; kill %1 ",
            "title": "CLI Hello Coherence"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " Create a maven project either manually or by using an archetype such as maven-archetype-quickstart Add a dependency to the pom file: <markup lang=\"xml\" title=\"pom.xml\" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Copy and paste the following source to a file named src/main/java/HelloCoherence.java: <markup lang=\"java\" title=\"HelloCoherence.java\" >import com.tangosol.net.CacheFactory; import com.tangosol.net.NamedMap public class HelloCoherence { // ----- static methods ------------------------------------------------- public static void main(String[] asArgs) { NamedMap&lt;String, String&gt; map = CacheFactory.getCache(\"welcomes\"); System.out.printf(\"Accessing map \\\"%s\\\" containing %d entries\", map.getName(), map.size()); map.put(\"english\", \"Hello\"); map.put(\"spanish\", \"Hola\"); map.put(\"french\" , \"Bonjour\"); // list map.entrySet().forEach(System.out::println); } } Compile the maven project: <markup lang=\"shell\" >mvn package Start a Storage server <markup lang=\"shell\" >mvn exec:java -Dexec.mainClass=\"com.tangosol.net.DefaultCacheServer\" &amp; Run HelloCoherence <markup lang=\"shell\" >mvn exec:java -Dexec.mainClass=\"HelloCoherence\" Confirm that you see the output including the following: <markup lang=\"shell\" >Accessing map \"welcomes\" containing 3 entries ConverterEntry{Key=\"french\", Value=\"Bonjour\"} ConverterEntry{Key=\"spanish\", Value=\"Hola\"} ConverterEntry{Key=\"english\", Value=\"Hello\"} Kill the storage server started earlier: <markup lang=\"shell\" >kill %1 ",
            "title": "Build HelloCoherence "
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": " The following example illustrates starting a storage enabled Coherence server, followed by running the HelloCoherence application. The HelloCoherence application inserts and retrieves data from the Coherence server. Build HelloCoherence Create a maven project either manually or by using an archetype such as maven-archetype-quickstart Add a dependency to the pom file: <markup lang=\"xml\" title=\"pom.xml\" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Copy and paste the following source to a file named src/main/java/HelloCoherence.java: <markup lang=\"java\" title=\"HelloCoherence.java\" >import com.tangosol.net.CacheFactory; import com.tangosol.net.NamedMap public class HelloCoherence { // ----- static methods ------------------------------------------------- public static void main(String[] asArgs) { NamedMap&lt;String, String&gt; map = CacheFactory.getCache(\"welcomes\"); System.out.printf(\"Accessing map \\\"%s\\\" containing %d entries\", map.getName(), map.size()); map.put(\"english\", \"Hello\"); map.put(\"spanish\", \"Hola\"); map.put(\"french\" , \"Bonjour\"); // list map.entrySet().forEach(System.out::println); } } Compile the maven project: <markup lang=\"shell\" >mvn package Start a Storage server <markup lang=\"shell\" >mvn exec:java -Dexec.mainClass=\"com.tangosol.net.DefaultCacheServer\" &amp; Run HelloCoherence <markup lang=\"shell\" >mvn exec:java -Dexec.mainClass=\"HelloCoherence\" Confirm that you see the output including the following: <markup lang=\"shell\" >Accessing map \"welcomes\" containing 3 entries ConverterEntry{Key=\"french\", Value=\"Bonjour\"} ConverterEntry{Key=\"spanish\", Value=\"Hola\"} ConverterEntry{Key=\"english\", Value=\"Hello\"} Kill the storage server started earlier: <markup lang=\"shell\" >kill %1 ",
            "title": " Programmatic Hello Coherence Example"
        },
        {
            "location": "/docs/about/03_quickstart",
            "text": "<markup lang=\"shell\" >$&gt; git clone git@github.com:oracle/coherence.git $&gt; cd coherence/prj # build all modules $&gt; mvn clean install # build all modules skipping tests $&gt; mvn clean install -DskipTests # build a specific module, including all dependent modules and run tests $&gt; mvn -am -pl test/functional/persistence clean verify # build only coherence.jar without running tests $&gt; mvn -am -pl coherence clean install -DskipTests # build only coherence.jar and skip compilation of CDBs and tests $&gt; mvn -am -pl coherence clean install -DskipTests -Dtde.compile.not.required ",
            "title": " Building"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Coherence CDI provides support for CDI (Contexts and Dependency Injection) within Coherence cluster members. It allows you both to inject Coherence-managed resources, such as NamedMap , NamedCache and Session instances into CDI managed beans, to inject CDI beans into Coherence-managed resources, such as event interceptors and cache stores, and to handle Coherence server-side events using CDI observer methods. In addition, Coherence CDI provides support for automatic injection of transient objects upon deserialization. This allows you to inject CDI managed beans such as services and repositories (to use DDD nomenclature) into transient objects, such as entry processor and even data class instances, greatly simplifying implementation of true Domain Driven applications. ",
            "title": "Coherence CDI"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " You can also inject views , by simply adding View qualifier to either NamedMap or NamedCache : <markup lang=\"java\" >import com.oracle.coherence.cdi.View; import javax.inject.Inject; @Inject @View private NamedMap&lt;Long, Person&gt; people; @Inject @View private NamedCache&lt;Long, Product&gt; products; The examples above are equivalent, and both will bring all the data from the backing map into a local view, as they will use AlwaysFilter when constructing a view. If you want to limit the data in the view to a subset, you can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.WhereFilter; import javax.inject.Inject; @Inject @View @WhereFilter(\"gender = 'MALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; men; @Inject @View @WhereFilter(\"gender = 'FEMALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; women; The views also support transformation of the entry values on the server, in order to reduce both the amount of data stored locally, and the amount of data transferred over the network. For example, you may have a complex Person objects in the backing map, but only need their names in order to populate a drop down on the client UI. In that case, you can implement a custom ExtractorBinding (recommended), or use a built-in @PropertyExtractor for convenience: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.PropertyExtractor; import javax.inject.Inject; @Inject @View @PropertyExtractor(\"fullName\") @Name(\"people\") private NamedMap&lt;Long, String&gt; names; Note that the value type in the example above has changed from Person to String , due to server-side transformation caused by the specified @PropertyExtractor . ",
            "title": "Inject Views"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " In order to inject an instance of a NamedMap into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import javax.inject.Inject; @Inject private NamedMap&lt;Long, Person&gt; people; In the example above we&#8217;ve assumed that the map name you want to inject is the same as the name of the field you are injecting into, people . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the map you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"people\") private NamedMap&lt;Long, Person&gt; m_people; This is also what you have to do if you are using constructor injection or setter injection: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject public MyClass(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } @Inject public void setPeople(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the cache or map: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject @Name(\"Products\") private NamedCache&lt;Long, Product&gt; products; @Inject @SessionName(\"Customers\") private NamedCache&lt;Long, Customer&gt; customers; You can replace NamedMap or NamedCache in any of the examples above with AsyncNamedCache and AsyncNamedCache respectively, in order to inject asynchronous variant of those APIs: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private AsyncNamedMap&lt;Long, Person&gt; people; @Inject @SessionName(\"Products\") private AsyncNamedCache&lt;Long, Person&gt; Product; Inject Views You can also inject views , by simply adding View qualifier to either NamedMap or NamedCache : <markup lang=\"java\" >import com.oracle.coherence.cdi.View; import javax.inject.Inject; @Inject @View private NamedMap&lt;Long, Person&gt; people; @Inject @View private NamedCache&lt;Long, Product&gt; products; The examples above are equivalent, and both will bring all the data from the backing map into a local view, as they will use AlwaysFilter when constructing a view. If you want to limit the data in the view to a subset, you can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.WhereFilter; import javax.inject.Inject; @Inject @View @WhereFilter(\"gender = 'MALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; men; @Inject @View @WhereFilter(\"gender = 'FEMALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; women; The views also support transformation of the entry values on the server, in order to reduce both the amount of data stored locally, and the amount of data transferred over the network. For example, you may have a complex Person objects in the backing map, but only need their names in order to populate a drop down on the client UI. In that case, you can implement a custom ExtractorBinding (recommended), or use a built-in @PropertyExtractor for convenience: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.PropertyExtractor; import javax.inject.Inject; @Inject @View @PropertyExtractor(\"fullName\") @Name(\"people\") private NamedMap&lt;Long, String&gt; names; Note that the value type in the example above has changed from Person to String , due to server-side transformation caused by the specified @PropertyExtractor . ",
            "title": "Injecting NamedMap , NamedCache and related objects"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " In order to inject an instance of a NamedTopic into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject private NamedTopic&lt;Order&gt; orders; In the example above we&#8217;ve assumed that the topic name you want to inject is the same as the name of the field you are injecting into, in this case orders . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the topic you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @Name(\"orders\") private NamedTopic&lt;Order&gt; topic; This is also what you have to do if you are using constructor or setter injection instead: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject public MyClass(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } @Inject public void setOrdersTopic(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the topic: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @SessionName(\"Finance\") private NamedTopic&lt;PaymentRequest&gt; payments; @Inject @SessionName(\"Shipping\") private NamedTopic&lt;ShippingRequest&gt; shipments; The examples above allow you to inject a NamedTopic instance into your CDI bean, but it is often simpler and more convenient to inject Publisher or Subscriber for a given topic instead. This can be easily accomplished by replacing NamedTopic&lt;T&gt; in any of the examples above with either Publisher&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Publisher&lt;Order&gt; orders; @Inject @Name(\"orders\") private Publisher&lt;Order&gt; m_orders; @Inject @SessionName(\"payments-cluster.xml\") private Publisher&lt;PaymentRequest&gt; payments; or Subscriber&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Subscriber&lt;Order&gt; orders; @Inject @Name(\"orders\") private Subscriber&lt;Order&gt; m_orders; @Inject @SessionName(\"Finance\") private Subscriber&lt;PaymentRequest&gt; payments; Topic metadata, such as topic name (based on either injection point name or the explicit name from @Name annotation), scope and message type, will be used under the hood to retrieve the NamedTopic , and to obtain Publisher or Subscriber from it. Additionally, if you want to place your Subscriber`s into a subscriber group (effectively turning a topic into a queue), you can easily accomplish that by adding `@SubscriberGroup qualifier to the injection point: <markup lang=\"java\" >import com.oracle.coherence.cdi.SubscriberGroup; import javax.inject.Inject; @Inject @SubscriberGroup(\"orders-queue\") private Subscriber&lt;Order&gt; orders; ",
            "title": "Injecting NamedTopic and related objects"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " If you need an instance of a Cluster interface somewhere in your application, you can easily obtain it via injection: <markup lang=\"java\" >import com.tangosol.net.Cluster; import javax.inject.Inject; @Inject private Cluster cluster; You can do the same if you need an instance of an OperationalContext : <markup lang=\"java\" >import com.tangosol.net.OperationalContext; import javax.inject.Inject; @Inject private OperationalContext ctx; ",
            "title": " Cluster and OperationalContext Injection"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " On rare occasions when you need to use a Session directly, Coherence CDI makes it trivial to do so. Coherence will create a default Session when the CDI server starts, this will be created using the normal default cache configuration file. Other named sessions can be configured as CDI beans of type SessionConfiguration . For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class MySession implements SessionInitializer { public String getName() { return \"Foo\"; } // implement session configuration methods } The bean above will create the configuration for a Session named Foo . When the CDI server starts the session will be created and can then be injected into other beans. A simpler way to create a SessionConfiguration is to implement the SessionIntializer interface and annotate the class. For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Scope; import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @ApplicationScoped @Named(\"Foo\") @Scope(\"Foo\") @ConfigUri(\"my-coherence-config.xml\") public class MySession implements SessionInitializer { } The above configuration will create a Session bean with a name of Foo a scoep of Foo with an underlying ConfigurableCacheFactory created from the my-coherence-config.xml configuration file. To obtain an instance of the default Session , all you need to do is inject it into the class which needs to use it: <markup lang=\"java\" >import com.tangosol.net.Session; import javax.inject.Inject; @Inject private Session session; If you need a specific named Session you can simply qualify one using @Name qualifier and specifying the Session name: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"SessionOne\") private Session sessionOne; @Inject @Name(\"SessionTwo\") private Session sessionTwo; ",
            "title": "Named Session Injection"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " While in most cases you won&#8217;t have to deal with serializers directly, Coherence CDI makes it simple to obtain named serializers (and to register new ones) when you need. To get a default Serializer for the current context class loader, you can simply inject it: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.inject.Inject; @Inject private Serializer defaultSerializer; However, it may be more useful to inject one of the named serializers defined in the operational configuration, which can be easily accomplished using @Name qualifier: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"java\") private Serializer javaSerializer; @Inject @Name(\"pof\") private Serializer pofSerializer; In addition to the serializers defined in the operational config, the example above will also perform BeanManager lookup for a named bean that implements Serializer interface. That means that if you implemented a custom Serializer bean, such as: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @Named(\"json\") @ApplicationScoped public class JsonSerializer implements Serializer { ... } it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily as the named serializers defined in the operational config: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"json\") private Serializer jsonSerializer; ",
            "title": " Serializer Injection"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " POF serializers can be injected by using both the @Name and @ConfigUri qualifiers to inject a POF serializer which uses a specific POF configuration file. <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"pof\") @ConfigUri(\"test-pof-config.xml\") private Serializer pofSerializer; The code above will inject a POF serializer that uses test-pof-config.xml as its configuration file. ",
            "title": "Inject a POF Serializer With a Specific POF Configuration"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " While the injection of a NamedMap , NamedCache , NamedTopic , and related instances, as shown above, is probably the single most used feature of Coherence CDI, it is certainly not the only one. The following sections describe other Coherence artifacts that can be injected using Coherence CDI. Cluster and OperationalContext Injection If you need an instance of a Cluster interface somewhere in your application, you can easily obtain it via injection: <markup lang=\"java\" >import com.tangosol.net.Cluster; import javax.inject.Inject; @Inject private Cluster cluster; You can do the same if you need an instance of an OperationalContext : <markup lang=\"java\" >import com.tangosol.net.OperationalContext; import javax.inject.Inject; @Inject private OperationalContext ctx; Named Session Injection On rare occasions when you need to use a Session directly, Coherence CDI makes it trivial to do so. Coherence will create a default Session when the CDI server starts, this will be created using the normal default cache configuration file. Other named sessions can be configured as CDI beans of type SessionConfiguration . For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class MySession implements SessionInitializer { public String getName() { return \"Foo\"; } // implement session configuration methods } The bean above will create the configuration for a Session named Foo . When the CDI server starts the session will be created and can then be injected into other beans. A simpler way to create a SessionConfiguration is to implement the SessionIntializer interface and annotate the class. For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Scope; import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @ApplicationScoped @Named(\"Foo\") @Scope(\"Foo\") @ConfigUri(\"my-coherence-config.xml\") public class MySession implements SessionInitializer { } The above configuration will create a Session bean with a name of Foo a scoep of Foo with an underlying ConfigurableCacheFactory created from the my-coherence-config.xml configuration file. To obtain an instance of the default Session , all you need to do is inject it into the class which needs to use it: <markup lang=\"java\" >import com.tangosol.net.Session; import javax.inject.Inject; @Inject private Session session; If you need a specific named Session you can simply qualify one using @Name qualifier and specifying the Session name: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"SessionOne\") private Session sessionOne; @Inject @Name(\"SessionTwo\") private Session sessionTwo; Serializer Injection While in most cases you won&#8217;t have to deal with serializers directly, Coherence CDI makes it simple to obtain named serializers (and to register new ones) when you need. To get a default Serializer for the current context class loader, you can simply inject it: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.inject.Inject; @Inject private Serializer defaultSerializer; However, it may be more useful to inject one of the named serializers defined in the operational configuration, which can be easily accomplished using @Name qualifier: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"java\") private Serializer javaSerializer; @Inject @Name(\"pof\") private Serializer pofSerializer; In addition to the serializers defined in the operational config, the example above will also perform BeanManager lookup for a named bean that implements Serializer interface. That means that if you implemented a custom Serializer bean, such as: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @Named(\"json\") @ApplicationScoped public class JsonSerializer implements Serializer { ... } it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily as the named serializers defined in the operational config: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"json\") private Serializer jsonSerializer; Inject a POF Serializer With a Specific POF Configuration POF serializers can be injected by using both the @Name and @ConfigUri qualifiers to inject a POF serializer which uses a specific POF configuration file. <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"pof\") @ConfigUri(\"test-pof-config.xml\") private Serializer pofSerializer; The code above will inject a POF serializer that uses test-pof-config.xml as its configuration file. ",
            "title": "Other Supported Injection Points"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " CDI, and dependency injection in general, make it easy for application classes to declare the dependencies they need and let the runtime provide them when necessary. This makes the applications easier to develop, test and reason about, and the code extremely clean. Coherence CDI allows you to do the same for Coherence objects, such as Cluster , Session , NamedMap , NamedCache , ContinuousQueryCache , ConfigurableCacheFactory , etc. Injecting NamedMap , NamedCache and related objects In order to inject an instance of a NamedMap into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import javax.inject.Inject; @Inject private NamedMap&lt;Long, Person&gt; people; In the example above we&#8217;ve assumed that the map name you want to inject is the same as the name of the field you are injecting into, people . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the map you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"people\") private NamedMap&lt;Long, Person&gt; m_people; This is also what you have to do if you are using constructor injection or setter injection: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject public MyClass(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } @Inject public void setPeople(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the cache or map: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject @Name(\"Products\") private NamedCache&lt;Long, Product&gt; products; @Inject @SessionName(\"Customers\") private NamedCache&lt;Long, Customer&gt; customers; You can replace NamedMap or NamedCache in any of the examples above with AsyncNamedCache and AsyncNamedCache respectively, in order to inject asynchronous variant of those APIs: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private AsyncNamedMap&lt;Long, Person&gt; people; @Inject @SessionName(\"Products\") private AsyncNamedCache&lt;Long, Person&gt; Product; Inject Views You can also inject views , by simply adding View qualifier to either NamedMap or NamedCache : <markup lang=\"java\" >import com.oracle.coherence.cdi.View; import javax.inject.Inject; @Inject @View private NamedMap&lt;Long, Person&gt; people; @Inject @View private NamedCache&lt;Long, Product&gt; products; The examples above are equivalent, and both will bring all the data from the backing map into a local view, as they will use AlwaysFilter when constructing a view. If you want to limit the data in the view to a subset, you can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.WhereFilter; import javax.inject.Inject; @Inject @View @WhereFilter(\"gender = 'MALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; men; @Inject @View @WhereFilter(\"gender = 'FEMALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; women; The views also support transformation of the entry values on the server, in order to reduce both the amount of data stored locally, and the amount of data transferred over the network. For example, you may have a complex Person objects in the backing map, but only need their names in order to populate a drop down on the client UI. In that case, you can implement a custom ExtractorBinding (recommended), or use a built-in @PropertyExtractor for convenience: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.PropertyExtractor; import javax.inject.Inject; @Inject @View @PropertyExtractor(\"fullName\") @Name(\"people\") private NamedMap&lt;Long, String&gt; names; Note that the value type in the example above has changed from Person to String , due to server-side transformation caused by the specified @PropertyExtractor . Injecting NamedTopic and related objects In order to inject an instance of a NamedTopic into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject private NamedTopic&lt;Order&gt; orders; In the example above we&#8217;ve assumed that the topic name you want to inject is the same as the name of the field you are injecting into, in this case orders . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the topic you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @Name(\"orders\") private NamedTopic&lt;Order&gt; topic; This is also what you have to do if you are using constructor or setter injection instead: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject public MyClass(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } @Inject public void setOrdersTopic(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the topic: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @SessionName(\"Finance\") private NamedTopic&lt;PaymentRequest&gt; payments; @Inject @SessionName(\"Shipping\") private NamedTopic&lt;ShippingRequest&gt; shipments; The examples above allow you to inject a NamedTopic instance into your CDI bean, but it is often simpler and more convenient to inject Publisher or Subscriber for a given topic instead. This can be easily accomplished by replacing NamedTopic&lt;T&gt; in any of the examples above with either Publisher&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Publisher&lt;Order&gt; orders; @Inject @Name(\"orders\") private Publisher&lt;Order&gt; m_orders; @Inject @SessionName(\"payments-cluster.xml\") private Publisher&lt;PaymentRequest&gt; payments; or Subscriber&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Subscriber&lt;Order&gt; orders; @Inject @Name(\"orders\") private Subscriber&lt;Order&gt; m_orders; @Inject @SessionName(\"Finance\") private Subscriber&lt;PaymentRequest&gt; payments; Topic metadata, such as topic name (based on either injection point name or the explicit name from @Name annotation), scope and message type, will be used under the hood to retrieve the NamedTopic , and to obtain Publisher or Subscriber from it. Additionally, if you want to place your Subscriber`s into a subscriber group (effectively turning a topic into a queue), you can easily accomplish that by adding `@SubscriberGroup qualifier to the injection point: <markup lang=\"java\" >import com.oracle.coherence.cdi.SubscriberGroup; import javax.inject.Inject; @Inject @SubscriberGroup(\"orders-queue\") private Subscriber&lt;Order&gt; orders; Other Supported Injection Points While the injection of a NamedMap , NamedCache , NamedTopic , and related instances, as shown above, is probably the single most used feature of Coherence CDI, it is certainly not the only one. The following sections describe other Coherence artifacts that can be injected using Coherence CDI. Cluster and OperationalContext Injection If you need an instance of a Cluster interface somewhere in your application, you can easily obtain it via injection: <markup lang=\"java\" >import com.tangosol.net.Cluster; import javax.inject.Inject; @Inject private Cluster cluster; You can do the same if you need an instance of an OperationalContext : <markup lang=\"java\" >import com.tangosol.net.OperationalContext; import javax.inject.Inject; @Inject private OperationalContext ctx; Named Session Injection On rare occasions when you need to use a Session directly, Coherence CDI makes it trivial to do so. Coherence will create a default Session when the CDI server starts, this will be created using the normal default cache configuration file. Other named sessions can be configured as CDI beans of type SessionConfiguration . For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class MySession implements SessionInitializer { public String getName() { return \"Foo\"; } // implement session configuration methods } The bean above will create the configuration for a Session named Foo . When the CDI server starts the session will be created and can then be injected into other beans. A simpler way to create a SessionConfiguration is to implement the SessionIntializer interface and annotate the class. For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Scope; import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @ApplicationScoped @Named(\"Foo\") @Scope(\"Foo\") @ConfigUri(\"my-coherence-config.xml\") public class MySession implements SessionInitializer { } The above configuration will create a Session bean with a name of Foo a scoep of Foo with an underlying ConfigurableCacheFactory created from the my-coherence-config.xml configuration file. To obtain an instance of the default Session , all you need to do is inject it into the class which needs to use it: <markup lang=\"java\" >import com.tangosol.net.Session; import javax.inject.Inject; @Inject private Session session; If you need a specific named Session you can simply qualify one using @Name qualifier and specifying the Session name: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"SessionOne\") private Session sessionOne; @Inject @Name(\"SessionTwo\") private Session sessionTwo; Serializer Injection While in most cases you won&#8217;t have to deal with serializers directly, Coherence CDI makes it simple to obtain named serializers (and to register new ones) when you need. To get a default Serializer for the current context class loader, you can simply inject it: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.inject.Inject; @Inject private Serializer defaultSerializer; However, it may be more useful to inject one of the named serializers defined in the operational configuration, which can be easily accomplished using @Name qualifier: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"java\") private Serializer javaSerializer; @Inject @Name(\"pof\") private Serializer pofSerializer; In addition to the serializers defined in the operational config, the example above will also perform BeanManager lookup for a named bean that implements Serializer interface. That means that if you implemented a custom Serializer bean, such as: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @Named(\"json\") @ApplicationScoped public class JsonSerializer implements Serializer { ... } it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily as the named serializers defined in the operational config: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"json\") private Serializer jsonSerializer; Inject a POF Serializer With a Specific POF Configuration POF serializers can be injected by using both the @Name and @ConfigUri qualifiers to inject a POF serializer which uses a specific POF configuration file. <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"pof\") @ConfigUri(\"test-pof-config.xml\") private Serializer pofSerializer; The code above will inject a POF serializer that uses test-pof-config.xml as its configuration file. ",
            "title": "Injecting Coherence Objects into CDI Beans"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " The observer method above will receive all events for the people map, but you can also control the types of events received using event qualifiers: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onChange(@Observes @Inserted @Updated @Removed @MapName(\"people\") EntryEvent&lt;?, ?&gt; event) { // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache } ",
            "title": "Observe Specific Event Types"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } ",
            "title": "Filter Observed Events"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type EntryEvent&lt;Long, Person&gt; this method will receive events of type EntryEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type EntryEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. ",
            "title": "Transform Observed Events"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " In addition, to the @MapName qualifier, you can also use @ServiceName and @ScopeName qualifiers as a way to limit the events received. The examples above show only how to handle EntryEvent s, but the same applies to all other server-side event types: <markup lang=\"java\" >private void onActivated(@Observes @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@Observes @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@Observes @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people' map/cache } ",
            "title": "Observe Events for Maps and Caches in Specific Services and Scopes"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " All the examples above used synchronous observers by specifying @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onActivated(@ObservesAsync @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@ObservesAsync @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@ObservesAsync @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people', map/cache } Warning Coherence events fall into two categories: pre- and post-commit events. All the events whose name ends with \"ing\" , such as Inserting , Updating , Removing or Executing are pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception, but in order to do so they must be synchronous to ensure that they are executed on the same thread that is executing the operation that triggered the event. That means that you can observe them using asynchronous CDI observers, but if you want to mutate the set of entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous CDI observer. ",
            "title": "Using Asynchronous Observers"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " While the above examples show that you can implement any Coherence EventInterceptor as a CDI bean and register it using &lt;cdi:bean&gt; element within the cache configuration file, Coherence CDI also provides a much simpler way to accomplish the same goal using standard CDI Events and Observers. For example, to observe events raised by a NamedMap with the name people , with keys of type Long and values of type Person , you would define a CDI observer such as this one: <markup lang=\"java\" >private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Observe Specific Event Types The observer method above will receive all events for the people map, but you can also control the types of events received using event qualifiers: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onChange(@Observes @Inserted @Updated @Removed @MapName(\"people\") EntryEvent&lt;?, ?&gt; event) { // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache } Filter Observed Events The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Transform Observed Events When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type EntryEvent&lt;Long, Person&gt; this method will receive events of type EntryEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type EntryEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. Observe Events for Maps and Caches in Specific Services and Scopes In addition, to the @MapName qualifier, you can also use @ServiceName and @ScopeName qualifiers as a way to limit the events received. The examples above show only how to handle EntryEvent s, but the same applies to all other server-side event types: <markup lang=\"java\" >private void onActivated(@Observes @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@Observes @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@Observes @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people' map/cache } Using Asynchronous Observers All the examples above used synchronous observers by specifying @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onActivated(@ObservesAsync @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@ObservesAsync @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@ObservesAsync @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people', map/cache } Warning Coherence events fall into two categories: pre- and post-commit events. All the events whose name ends with \"ing\" , such as Inserting , Updating , Removing or Executing are pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception, but in order to do so they must be synchronous to ensure that they are executed on the same thread that is executing the operation that triggered the event. That means that you can observe them using asynchronous CDI observers, but if you want to mutate the set of entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous CDI observer. ",
            "title": "Using CDI Observers to Handle Coherence Server-Side Events"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Coherence has a number of server-side extension points, which allow users to customize application behavior in different ways, typically by configuring their extensions within various sections of the cache configuration file. For example, the users can implement event interceptors and cache stores, in order to handle server-side events and integrate with the external data stores and other services. Coherence CDI provides a way to inject named CDI beans into these extension points using custom configuration namespace handler. <markup lang=\"xml\" >&lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xmlns:cdi=\"class://com.oracle.coherence.cdi.server.CdiNamespaceHandler\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; Once you&#8217;ve declared the handler for the cdi namespace above, you can specify &lt;cdi:bean&gt; element in any place where you would normally use &lt;class-name&gt; or &lt;class-factory-name&gt; elements: <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xmlns:cdi=\"class://com.oracle.coherence.cdi.server.CdiNamespaceHandler\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;registrationListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;activationListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;*&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-scheme&lt;/scheme-name&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;cacheListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-scheme&lt;/scheme-name&gt; &lt;service-name&gt;PartitionedCache&lt;/service-name&gt; &lt;local-storage system-property=\"coherence.distributed.localstorage\"&gt;true&lt;/local-storage&gt; &lt;partition-listener&gt; &lt;cdi:bean&gt;partitionListener&lt;/cdi:bean&gt; &lt;/partition-listener&gt; &lt;member-listener&gt; &lt;cdi:bean&gt;memberListener&lt;/cdi:bean&gt; &lt;/member-listener&gt; &lt;backing-map-scheme&gt; &lt;local-scheme/&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;storageListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; Note that you can only inject named CDI beans (beans with an explicit @Named annotations) via &lt;cdi:bean&gt; element. For example, the cacheListener interceptor bean used above would look similar to this: <markup lang=\"java\" >@ApplicationScoped @Named(\"cacheListener\") @EntryEvents(INSERTING) public class MyCacheListener implements EventInterceptor&lt;EntryEvent&lt;Long, String&gt;&gt; { @Override public void onEvent(EntryEvent&lt;Long, String&gt; e) { // handle INSERTING event } } Also keep in mind that only @ApplicationScoped beans can be injected, which implies that they may be shared. For example, because we&#8217;ve used a wildcard, * , as a cache name within the cache mapping in the example above, the same instance of cacheListener will receive events from multiple caches. This is typically fine, as the event itself provides the details about the context that raised it, including cache name, and the service it was raised from, but it does imply that any shared state that you may have within your listener class shouldn&#8217;t be context-specific, and it must be safe for concurrent access from multiple threads. If you can&#8217;t guarantee the latter, you may want to declare the onEvent method as synchronized , to ensure only one thread at a time can access any shared state you may have. Using CDI Observers to Handle Coherence Server-Side Events While the above examples show that you can implement any Coherence EventInterceptor as a CDI bean and register it using &lt;cdi:bean&gt; element within the cache configuration file, Coherence CDI also provides a much simpler way to accomplish the same goal using standard CDI Events and Observers. For example, to observe events raised by a NamedMap with the name people , with keys of type Long and values of type Person , you would define a CDI observer such as this one: <markup lang=\"java\" >private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Observe Specific Event Types The observer method above will receive all events for the people map, but you can also control the types of events received using event qualifiers: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onChange(@Observes @Inserted @Updated @Removed @MapName(\"people\") EntryEvent&lt;?, ?&gt; event) { // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache } Filter Observed Events The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Transform Observed Events When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type EntryEvent&lt;Long, Person&gt; this method will receive events of type EntryEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type EntryEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. Observe Events for Maps and Caches in Specific Services and Scopes In addition, to the @MapName qualifier, you can also use @ServiceName and @ScopeName qualifiers as a way to limit the events received. The examples above show only how to handle EntryEvent s, but the same applies to all other server-side event types: <markup lang=\"java\" >private void onActivated(@Observes @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@Observes @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@Observes @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people' map/cache } Using Asynchronous Observers All the examples above used synchronous observers by specifying @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onActivated(@ObservesAsync @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@ObservesAsync @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@ObservesAsync @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people', map/cache } Warning Coherence events fall into two categories: pre- and post-commit events. All the events whose name ends with \"ing\" , such as Inserting , Updating , Removing or Executing are pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception, but in order to do so they must be synchronous to ensure that they are executed on the same thread that is executing the operation that triggered the event. That means that you can observe them using asynchronous CDI observers, but if you want to mutate the set of entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous CDI observer. ",
            "title": "Injecting CDI Beans into Coherence-managed Objects"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " While not technically a true marker interface, Injectable can be treated as such for all intents and purposes. All you need to do is add it to the implements clause of your class in order for injection on deserialization to kick in: <markup lang=\"java\" >public class InjectableBean implements Injectable, Serializable { @Inject private Converter&lt;String, String&gt; converter; private String text; InjectableBean() { } InjectableBean(String text) { this.text = text; } String getConvertedText() { return converter.convert(text); } } Assuming that you have the following Converter service implementation in your application, it will be injected into InjectableBean during deserialization, and the getConvertedText method will return the value of the text field converted to upper case: <markup lang=\"java\" >@ApplicationScoped public class ToUpperConverter implements Converter&lt;String, String&gt; { @Override public String convert(String s) { return s.toUpperCase(); } } If your Injectable class has @PostConstruct callback method, it will be called after the injection. However, because we have no control over object&#8217;s lifecycle after that point, @PreDestroy callback will never be called). You should note that the above functionality is not dependent on the serialization format and will work with both Java and POF serialization (or any other custom serializer), and for any object that is deserialized on any Coherence member (or even on a remote client). While the deserialized transient objects are not true CDI managed beans, being able to inject CDI managed dependencies into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those application components. We hope you&#8217;ll find it useful. ",
            "title": "Making transient classes Injectable "
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Using CDI to inject Coherence objects into your application classes, and CDI beans into Coherence-managed objects will allow you to support many use cases where dependency injection may be useful, but it doesn&#8217;t cover an important use case that is somewhat specific to Coherence. Coherence is a distributed system, and it uses serialization in order to send both the data and the processing requests from one cluster member (or remote client) to another, as well as to store data, both in memory and on disk. Processing requests, such as entry processors and aggregators, have to be deserialized on a target cluster member(s) in order to be executed. In some cases, they could benefit from dependency injection in order to avoid service lookups. Similarly, while the data is stored in a serialized, binary format, it may need to be deserialized into user supplied classes for server-side processing, such as when executing entry processors and aggregators. In this case, data classes can often also benefit from dependency injection (in order to support Domain-Driven Design (DDD), for example). While these transient objects are not managed by the CDI container, Coherence CDI does support their injection during deserialization, but for performance reasons requires that you explicitly opt-in by implementing com.oracle.coherence.cdi.Injectable interface. Making transient classes Injectable While not technically a true marker interface, Injectable can be treated as such for all intents and purposes. All you need to do is add it to the implements clause of your class in order for injection on deserialization to kick in: <markup lang=\"java\" >public class InjectableBean implements Injectable, Serializable { @Inject private Converter&lt;String, String&gt; converter; private String text; InjectableBean() { } InjectableBean(String text) { this.text = text; } String getConvertedText() { return converter.convert(text); } } Assuming that you have the following Converter service implementation in your application, it will be injected into InjectableBean during deserialization, and the getConvertedText method will return the value of the text field converted to upper case: <markup lang=\"java\" >@ApplicationScoped public class ToUpperConverter implements Converter&lt;String, String&gt; { @Override public String convert(String s) { return s.toUpperCase(); } } If your Injectable class has @PostConstruct callback method, it will be called after the injection. However, because we have no control over object&#8217;s lifecycle after that point, @PreDestroy callback will never be called). You should note that the above functionality is not dependent on the serialization format and will work with both Java and POF serialization (or any other custom serializer), and for any object that is deserialized on any Coherence member (or even on a remote client). While the deserialized transient objects are not true CDI managed beans, being able to inject CDI managed dependencies into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those application components. We hope you&#8217;ll find it useful. ",
            "title": "Injecting CDI Beans into Transient Objects"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Creating the filter annotation is simply creating a normal Java annotation class that is annotated with the @com.oracle.coherence.cdi.FilterBinding annotation. <markup lang=\"java\" >@Inherited @FilterBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomFilter { } The most important part is that this new annotation is annotated with FilterBinding so that the Coherence CDI extensions can recognise that it represents a Filter . ",
            "title": "Create the Custom Filter Annotation"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Once the custom annotation has been created a FilterFactories implementation can be created that will be responsible for producing instances of the required Filter . <markup lang=\"java\" >@ApplicationScoped @CustomFilter static class CustomFilterSupplier implements FilterFactory&lt;CustomFilter, Object&gt; { @Override public Filter&lt;Object&gt; create(CustomFilter annotation) { return new CustomComplexFilter(); } } The CustomFilterSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomFilterSupplier class has been annotated with the new filter binding annotation @CustomFilter so that the Coherence CDI extension can locate it when it needs to create Filters . The CustomFilterSupplier implements the FilterFactories interface&#8217;s create method where it creates the custom Filter implementation. ",
            "title": "Create the Custom Filter Factory"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Now there is both a custom annotation, and an annotated FilterFactories , the injection point requiring the Filter can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomFilter private NamedMap&lt;Long, Person&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive events matching the same custom Filter then the method can be annotated with the same custom filter annotation. <markup lang=\"java\" >@CustomFilter private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { ",
            "title": "Annotate the Injection Point"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " As already mentioned above, when creating views or subscribing to events, the view or events can be modified using Filters . The exact Filter implementation injected will be determined by the view or event observers qualifiers. Specifically any qualifier annotation that is itself annotated with the @FilterBinding annotation. This should be a familiar pattern to anyone who has worked with CDI interceptors. For example, if there is an injection point for a view that is a filtered view of an underlying map, but the filter required is more complex than those provided by the build in qualifiers, or is some custom filter implementation. The steps required are: Create a custom annotation class to represent the required Filter . Create a bean class implementing com.oracle.coherence.cdi.FilterFactory annotated with the custom annotation that will be the factory for producing instances of the custom Filter . Annotate the view injection point with the custom annotation. Create the Custom Filter Annotation Creating the filter annotation is simply creating a normal Java annotation class that is annotated with the @com.oracle.coherence.cdi.FilterBinding annotation. <markup lang=\"java\" >@Inherited @FilterBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomFilter { } The most important part is that this new annotation is annotated with FilterBinding so that the Coherence CDI extensions can recognise that it represents a Filter . Create the Custom Filter Factory Once the custom annotation has been created a FilterFactories implementation can be created that will be responsible for producing instances of the required Filter . <markup lang=\"java\" >@ApplicationScoped @CustomFilter static class CustomFilterSupplier implements FilterFactory&lt;CustomFilter, Object&gt; { @Override public Filter&lt;Object&gt; create(CustomFilter annotation) { return new CustomComplexFilter(); } } The CustomFilterSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomFilterSupplier class has been annotated with the new filter binding annotation @CustomFilter so that the Coherence CDI extension can locate it when it needs to create Filters . The CustomFilterSupplier implements the FilterFactories interface&#8217;s create method where it creates the custom Filter implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated FilterFactories , the injection point requiring the Filter can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomFilter private NamedMap&lt;Long, Person&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive events matching the same custom Filter then the method can be annotated with the same custom filter annotation. <markup lang=\"java\" >@CustomFilter private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { ",
            "title": "FilterBinding Annotations"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " The @PropertyExtractor annotation can used to obtain an extractor that extracts a named property from an object. The value field of the @PropertyExtractor annotation is name of the property to extract. For example, this @PropertyExtractor annotation represents a ValueExtractor that will extract the lastName property from a value. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") The extractor produced will be an instance of com.tangosol.util.extractor.UniversalExtractor , so the example above is the same as calling: <markup lang=\"java\" >new UniversalExtractor(\"lastName\"); The @PropertyExtractor annotation can be applied multiple times to create a MultiExtractor that will extract a List of properties from a value. For example, if there was a map named people , where the map values are instances of Person , that has a firstName and a lastName property. The event observer below would observe events on that map, but the event received would only contain the event key, and a List containing the extracted firstName and lastName from the original event. where the event values will be a list of <markup lang=\"java\" >@PropertyExtractor(\"firstName\") @PropertyExtractor(\"lastName\") private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { ",
            "title": "PropertyExtractor"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " The @ChainedExtractor annotation can be used to extract a chain of properties. For example, a Person instance might contain an address property that contains a city property. The @ChainedExtractor takes the chain of fields to be extracted, in this case, extract the address from Person and then extract the city from the address . <markup lang=\"java\" >@ChainedExtractor(\"address\", \"city\") Each of the property names is used to create a UniversalExtractor , and the array of these extractors is used to create an instance of com.tangosol.util.extractor.ChainedExtractor . The example above would be the same as calling: <markup lang=\"java\" >UniversalExtractor[] chain = new UniversalExtractor[] { new UniversalExtractor(\"address\"), new UniversalExtractor(\"city\") }; ChainedExtractor extractor = new ChainedExtractor(chain); ",
            "title": "ChainedExtractor"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " The @PofExtractor annotation can be used to produce extractors that can extract properties from POF encoded values. The value passed to the @PofExtractor annotation is the POF path to navigate to the property to extract. For example, if a Person value has been serialized using POF with a lastName property at index 4 a @PofExtractor annotation could be used like this: <markup lang=\"java\" >@PofExtractor(index = 4) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(null, 4); Sometimes (for example when dealing with certain types of Number ) the PofExtractor needs to know they type to be extracted. In this case the type value can be set in the @PofExtractor annotation. For example, if a Book value had a sales field of type Long at POF index 2, the sales field could be extracted using the following @PofExtractor annotation: <markup lang=\"java\" >@PofExtractor(index = {2}, type = Long.class) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(Long.class, 2); The index value for a @PofExtractor annotation is an int array so multiple POF index values can be passed to navigate down a chain of properties to extract. For example if Person contained an Address at POF index 5 and Address contained a city property at POF index 3 the city could be extracted from a Person using the @PofExtractor annotation like this: <markup lang=\"java\" >@PofExtractor(index = {5, 3}) Alternatively if the value that will be extracted from is annotated with com.tangosol.io.pof.schema.annotation.PortableType and the POF serialization code for the class has been generated using the Coherence com.tangosol.io.pof.generator.PortableTypeGenerator then property names can be passed to the @PofExtractor annotation using its path field. For example to extract the lastName field from a POF serialized Person the @PofExtractor annotation can be used like this: <markup lang=\"java\" >@PofExtractor(path = \"lastName\") the address city example would be: <markup lang=\"java\" >@PofExtractor(path = {\"address\", \"city\"}) and the Book sales example would be: <markup lang=\"java\" >@PofExtractor(path = \"sales\", type Long.class) ",
            "title": "PofExtractor"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " PropertyExtractor The @PropertyExtractor annotation can used to obtain an extractor that extracts a named property from an object. The value field of the @PropertyExtractor annotation is name of the property to extract. For example, this @PropertyExtractor annotation represents a ValueExtractor that will extract the lastName property from a value. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") The extractor produced will be an instance of com.tangosol.util.extractor.UniversalExtractor , so the example above is the same as calling: <markup lang=\"java\" >new UniversalExtractor(\"lastName\"); The @PropertyExtractor annotation can be applied multiple times to create a MultiExtractor that will extract a List of properties from a value. For example, if there was a map named people , where the map values are instances of Person , that has a firstName and a lastName property. The event observer below would observe events on that map, but the event received would only contain the event key, and a List containing the extracted firstName and lastName from the original event. where the event values will be a list of <markup lang=\"java\" >@PropertyExtractor(\"firstName\") @PropertyExtractor(\"lastName\") private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { ChainedExtractor The @ChainedExtractor annotation can be used to extract a chain of properties. For example, a Person instance might contain an address property that contains a city property. The @ChainedExtractor takes the chain of fields to be extracted, in this case, extract the address from Person and then extract the city from the address . <markup lang=\"java\" >@ChainedExtractor(\"address\", \"city\") Each of the property names is used to create a UniversalExtractor , and the array of these extractors is used to create an instance of com.tangosol.util.extractor.ChainedExtractor . The example above would be the same as calling: <markup lang=\"java\" >UniversalExtractor[] chain = new UniversalExtractor[] { new UniversalExtractor(\"address\"), new UniversalExtractor(\"city\") }; ChainedExtractor extractor = new ChainedExtractor(chain); PofExtractor The @PofExtractor annotation can be used to produce extractors that can extract properties from POF encoded values. The value passed to the @PofExtractor annotation is the POF path to navigate to the property to extract. For example, if a Person value has been serialized using POF with a lastName property at index 4 a @PofExtractor annotation could be used like this: <markup lang=\"java\" >@PofExtractor(index = 4) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(null, 4); Sometimes (for example when dealing with certain types of Number ) the PofExtractor needs to know they type to be extracted. In this case the type value can be set in the @PofExtractor annotation. For example, if a Book value had a sales field of type Long at POF index 2, the sales field could be extracted using the following @PofExtractor annotation: <markup lang=\"java\" >@PofExtractor(index = {2}, type = Long.class) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(Long.class, 2); The index value for a @PofExtractor annotation is an int array so multiple POF index values can be passed to navigate down a chain of properties to extract. For example if Person contained an Address at POF index 5 and Address contained a city property at POF index 3 the city could be extracted from a Person using the @PofExtractor annotation like this: <markup lang=\"java\" >@PofExtractor(index = {5, 3}) Alternatively if the value that will be extracted from is annotated with com.tangosol.io.pof.schema.annotation.PortableType and the POF serialization code for the class has been generated using the Coherence com.tangosol.io.pof.generator.PortableTypeGenerator then property names can be passed to the @PofExtractor annotation using its path field. For example to extract the lastName field from a POF serialized Person the @PofExtractor annotation can be used like this: <markup lang=\"java\" >@PofExtractor(path = \"lastName\") the address city example would be: <markup lang=\"java\" >@PofExtractor(path = {\"address\", \"city\"}) and the Book sales example would be: <markup lang=\"java\" >@PofExtractor(path = \"sales\", type Long.class) ",
            "title": "Built-In ExtractorBinding Annotations"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " When the built-in extractor bindings are not suitable, or when a custom ValueExtractor implementation is required, then a custom extractor binding annotation can be created with a corresponding com.oracle.coherence.cdi.ExtractorFactory implementation. The steps required are: Create a custom annotation class to represent the required ValueExtractor . Create a bean class implementing com.oracle.coherence.cdi.ExtractorFactory annotated with the custom annotation that will be the factory for producing instances of the custom ValueExtractor . Annotate the view injection point with the custom annotation. ",
            "title": "Custom ExtractorBinding Annotations"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.ExtractorBinding annotation. <markup lang=\"java\" >@Inherited @ExtractorBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomExtractor { } The most important part is that this new annotation has been annotated with ExtractorBinding so that the Coherence CDI extensions can recognise that it represents a ValueExtractor . ",
            "title": "Create the Custom Extractor Annotation"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Once the custom annotation has been created an ExtractorFactory implementation can be created that will be responsible for producing instances of the required ValueExtractor . <markup lang=\"java\" >@ApplicationScoped @CustomExtractor static class CustomExtractorSupplier implements ExtractorFactory&lt;CustomExtractor, Object, Object&gt; { @Override public ValueExtractor&lt;Object, Object&gt; create(CustomExtractor annotation) { return new CustomComplexExtractor(); } } The CustomExtractorSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomExtractorSupplier class has been annotated with the new extractor binding annotation @CustomExtractor so that the Coherence CDI extension can locate it when it needs to create ValueExtractor instances. The CustomExtractorSupplier implements the ExtractorFactory interface&#8217;s create method where it creates the custom ValueExtractor implementation. ",
            "title": "Create the Custom Extractor Factory"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Now there is both a custom annotation, and an annotated ExtractorFactory , the injection point requiring the ValueExtractor can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomExtractor private NamedMap&lt;Long, String&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive transformed events using the custom extractor to transform the event: <markup lang=\"java\" >@CustomExtractor private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { ",
            "title": "Annotate the Injection Point"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Extractor bindings are annotations that are themselves annotated with @ExtractorBinding and are used in conjunction with an implementation of com.oracle.coherence.cdi.ExtractorFactory to produce Coherence ValueExtractor instances. There are a number of built-in extractor binding annotations in the Coherence CDI module and it is a simple process to provide custom implementations. Built-In ExtractorBinding Annotations PropertyExtractor The @PropertyExtractor annotation can used to obtain an extractor that extracts a named property from an object. The value field of the @PropertyExtractor annotation is name of the property to extract. For example, this @PropertyExtractor annotation represents a ValueExtractor that will extract the lastName property from a value. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") The extractor produced will be an instance of com.tangosol.util.extractor.UniversalExtractor , so the example above is the same as calling: <markup lang=\"java\" >new UniversalExtractor(\"lastName\"); The @PropertyExtractor annotation can be applied multiple times to create a MultiExtractor that will extract a List of properties from a value. For example, if there was a map named people , where the map values are instances of Person , that has a firstName and a lastName property. The event observer below would observe events on that map, but the event received would only contain the event key, and a List containing the extracted firstName and lastName from the original event. where the event values will be a list of <markup lang=\"java\" >@PropertyExtractor(\"firstName\") @PropertyExtractor(\"lastName\") private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { ChainedExtractor The @ChainedExtractor annotation can be used to extract a chain of properties. For example, a Person instance might contain an address property that contains a city property. The @ChainedExtractor takes the chain of fields to be extracted, in this case, extract the address from Person and then extract the city from the address . <markup lang=\"java\" >@ChainedExtractor(\"address\", \"city\") Each of the property names is used to create a UniversalExtractor , and the array of these extractors is used to create an instance of com.tangosol.util.extractor.ChainedExtractor . The example above would be the same as calling: <markup lang=\"java\" >UniversalExtractor[] chain = new UniversalExtractor[] { new UniversalExtractor(\"address\"), new UniversalExtractor(\"city\") }; ChainedExtractor extractor = new ChainedExtractor(chain); PofExtractor The @PofExtractor annotation can be used to produce extractors that can extract properties from POF encoded values. The value passed to the @PofExtractor annotation is the POF path to navigate to the property to extract. For example, if a Person value has been serialized using POF with a lastName property at index 4 a @PofExtractor annotation could be used like this: <markup lang=\"java\" >@PofExtractor(index = 4) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(null, 4); Sometimes (for example when dealing with certain types of Number ) the PofExtractor needs to know they type to be extracted. In this case the type value can be set in the @PofExtractor annotation. For example, if a Book value had a sales field of type Long at POF index 2, the sales field could be extracted using the following @PofExtractor annotation: <markup lang=\"java\" >@PofExtractor(index = {2}, type = Long.class) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(Long.class, 2); The index value for a @PofExtractor annotation is an int array so multiple POF index values can be passed to navigate down a chain of properties to extract. For example if Person contained an Address at POF index 5 and Address contained a city property at POF index 3 the city could be extracted from a Person using the @PofExtractor annotation like this: <markup lang=\"java\" >@PofExtractor(index = {5, 3}) Alternatively if the value that will be extracted from is annotated with com.tangosol.io.pof.schema.annotation.PortableType and the POF serialization code for the class has been generated using the Coherence com.tangosol.io.pof.generator.PortableTypeGenerator then property names can be passed to the @PofExtractor annotation using its path field. For example to extract the lastName field from a POF serialized Person the @PofExtractor annotation can be used like this: <markup lang=\"java\" >@PofExtractor(path = \"lastName\") the address city example would be: <markup lang=\"java\" >@PofExtractor(path = {\"address\", \"city\"}) and the Book sales example would be: <markup lang=\"java\" >@PofExtractor(path = \"sales\", type Long.class) Custom ExtractorBinding Annotations When the built-in extractor bindings are not suitable, or when a custom ValueExtractor implementation is required, then a custom extractor binding annotation can be created with a corresponding com.oracle.coherence.cdi.ExtractorFactory implementation. The steps required are: Create a custom annotation class to represent the required ValueExtractor . Create a bean class implementing com.oracle.coherence.cdi.ExtractorFactory annotated with the custom annotation that will be the factory for producing instances of the custom ValueExtractor . Annotate the view injection point with the custom annotation. Create the Custom Extractor Annotation Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.ExtractorBinding annotation. <markup lang=\"java\" >@Inherited @ExtractorBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomExtractor { } The most important part is that this new annotation has been annotated with ExtractorBinding so that the Coherence CDI extensions can recognise that it represents a ValueExtractor . Create the Custom Extractor Factory Once the custom annotation has been created an ExtractorFactory implementation can be created that will be responsible for producing instances of the required ValueExtractor . <markup lang=\"java\" >@ApplicationScoped @CustomExtractor static class CustomExtractorSupplier implements ExtractorFactory&lt;CustomExtractor, Object, Object&gt; { @Override public ValueExtractor&lt;Object, Object&gt; create(CustomExtractor annotation) { return new CustomComplexExtractor(); } } The CustomExtractorSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomExtractorSupplier class has been annotated with the new extractor binding annotation @CustomExtractor so that the Coherence CDI extension can locate it when it needs to create ValueExtractor instances. The CustomExtractorSupplier implements the ExtractorFactory interface&#8217;s create method where it creates the custom ValueExtractor implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated ExtractorFactory , the injection point requiring the ValueExtractor can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomExtractor private NamedMap&lt;Long, String&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive transformed events using the custom extractor to transform the event: <markup lang=\"java\" >@CustomExtractor private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { ",
            "title": "ExtractorBinding Annotations"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.MapEventTransformerBinding annotation. <markup lang=\"java\" >@Inherited @MapEventTransformerBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomTransformer { } The most important part is that this new annotation has been annotated with MapEventTransformerBinding so that the Coherence CDI extensions can recognise that it represents a MapEventTransformer . ",
            "title": "Create the Custom Extractor Annotation"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Once the custom annotation has been created an MapEventTransformerFactory implementation can be created that will be responsible for producing instances of the required MapEventTransformer . <markup lang=\"java\" >@ApplicationScoped @CustomTransformer static class CustomTransformerSupplier implements MapEventTransformerFactory&lt;CustomTransformer, Object, Object, Object&gt; { @Override public MapEventTransformer&lt;Object, Object, Object&gt; create(CustomTransformer annotation) { return new CustomComplexTransformer(); } } The CustomTransformerSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomTransformerSupplier class has been annotated with the new extractor binding annotation @CustomTransformer so that the Coherence CDI extension can locate it when it needs to create MapEventTransformer instances. The CustomTransformerSupplier implements the MapEventTransformerFactory interface&#8217;s create method where it creates the custom MapEventTransformer implementation. ",
            "title": "Create the Custom Extractor Factory"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Now there is both a custom annotation, and an annotated MapEventTransformerFactory , the observer method requiring the MapEventTransformer can be annotated with the new annotation. <markup lang=\"java\" >@CustomTransformer private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { ",
            "title": "Annotate the Injection Point"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " Coherence CDI supports event observers that can observe events for cache, or map, entries (see the Events section). The observer method can be annotated with a MapEventTransformerBinding annotation to indicate that the observer requires a transformer to be applied to the original event before it is observed. There are no built-in MapEventTransformerBinding annotations, this feature is to support use of custom MapEventTransformer implementations. The steps to create and use a MapEventTransformerBinding annotation are: Create a custom annotation class to represent the required MapEventTransformer . Create a bean class implementing com.oracle.coherence.cdi.MapEventTransformerFactory annotated with the custom annotation that will be the factory for producing instances of the custom MapEventTransformer . Annotate the view injection point with the custom annotation. Create the Custom Extractor Annotation Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.MapEventTransformerBinding annotation. <markup lang=\"java\" >@Inherited @MapEventTransformerBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomTransformer { } The most important part is that this new annotation has been annotated with MapEventTransformerBinding so that the Coherence CDI extensions can recognise that it represents a MapEventTransformer . Create the Custom Extractor Factory Once the custom annotation has been created an MapEventTransformerFactory implementation can be created that will be responsible for producing instances of the required MapEventTransformer . <markup lang=\"java\" >@ApplicationScoped @CustomTransformer static class CustomTransformerSupplier implements MapEventTransformerFactory&lt;CustomTransformer, Object, Object, Object&gt; { @Override public MapEventTransformer&lt;Object, Object, Object&gt; create(CustomTransformer annotation) { return new CustomComplexTransformer(); } } The CustomTransformerSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomTransformerSupplier class has been annotated with the new extractor binding annotation @CustomTransformer so that the Coherence CDI extension can locate it when it needs to create MapEventTransformer instances. The CustomTransformerSupplier implements the MapEventTransformerFactory interface&#8217;s create method where it creates the custom MapEventTransformer implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated MapEventTransformerFactory , the observer method requiring the MapEventTransformer can be annotated with the new annotation. <markup lang=\"java\" >@CustomTransformer private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { ",
            "title": "MapEventTransformerBinding Annotations"
        },
        {
            "location": "/coherence-cdi-server/README",
            "text": " In order to use Coherence CDI, you need to declare it as a dependency in your pom.xml : <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-cdi-server&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; Once the necessary dependency is in place, you can start using CDI to inject Coherence objects into managed CDI beans, and vice versa, as the following sections describe. Injecting Coherence Objects into CDI Beans Injecting NamedMap , NamedCache`, and related objects Injecting NamedMap or NamedCache Views Injecting NamedTopic and related objects Other Supported Injection Points Cluster and OperationalContext Injection Named Session Injection Serializer Injection Injecting CDI Beans into Coherence-managed Objects Using CDI Observers to Handle Coherence Server-Side Events Observer specific event types Filter the events to be observed Transform the events to be observed Observe events for maps and caches in specific scopes or services Using Asynchronous Observers Injecting CDI Beans into Transient Objects Making transient classes Injectable Filter Binding Annotations Extractor Binding Annotations Built-In Extractor Binding Annotations @PropertyExtractor @ChainedExtractor @PofExtractor Custom Extractor Binding Annotations MapEventTransformer Binding Annotations Injecting Coherence Objects into CDI Beans CDI, and dependency injection in general, make it easy for application classes to declare the dependencies they need and let the runtime provide them when necessary. This makes the applications easier to develop, test and reason about, and the code extremely clean. Coherence CDI allows you to do the same for Coherence objects, such as Cluster , Session , NamedMap , NamedCache , ContinuousQueryCache , ConfigurableCacheFactory , etc. Injecting NamedMap , NamedCache and related objects In order to inject an instance of a NamedMap into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import javax.inject.Inject; @Inject private NamedMap&lt;Long, Person&gt; people; In the example above we&#8217;ve assumed that the map name you want to inject is the same as the name of the field you are injecting into, people . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the map you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"people\") private NamedMap&lt;Long, Person&gt; m_people; This is also what you have to do if you are using constructor injection or setter injection: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject public MyClass(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } @Inject public void setPeople(@Name(\"people\") NamedMap&lt;Long, Person&gt; people) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the cache or map: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject @Name(\"Products\") private NamedCache&lt;Long, Product&gt; products; @Inject @SessionName(\"Customers\") private NamedCache&lt;Long, Customer&gt; customers; You can replace NamedMap or NamedCache in any of the examples above with AsyncNamedCache and AsyncNamedCache respectively, in order to inject asynchronous variant of those APIs: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private AsyncNamedMap&lt;Long, Person&gt; people; @Inject @SessionName(\"Products\") private AsyncNamedCache&lt;Long, Person&gt; Product; Inject Views You can also inject views , by simply adding View qualifier to either NamedMap or NamedCache : <markup lang=\"java\" >import com.oracle.coherence.cdi.View; import javax.inject.Inject; @Inject @View private NamedMap&lt;Long, Person&gt; people; @Inject @View private NamedCache&lt;Long, Product&gt; products; The examples above are equivalent, and both will bring all the data from the backing map into a local view, as they will use AlwaysFilter when constructing a view. If you want to limit the data in the view to a subset, you can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.WhereFilter; import javax.inject.Inject; @Inject @View @WhereFilter(\"gender = 'MALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; men; @Inject @View @WhereFilter(\"gender = 'FEMALE'\") @Name(\"people\") private NamedMap&lt;Long, Person&gt; women; The views also support transformation of the entry values on the server, in order to reduce both the amount of data stored locally, and the amount of data transferred over the network. For example, you may have a complex Person objects in the backing map, but only need their names in order to populate a drop down on the client UI. In that case, you can implement a custom ExtractorBinding (recommended), or use a built-in @PropertyExtractor for convenience: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.View; import com.oracle.coherence.cdi.PropertyExtractor; import javax.inject.Inject; @Inject @View @PropertyExtractor(\"fullName\") @Name(\"people\") private NamedMap&lt;Long, String&gt; names; Note that the value type in the example above has changed from Person to String , due to server-side transformation caused by the specified @PropertyExtractor . Injecting NamedTopic and related objects In order to inject an instance of a NamedTopic into your CDI bean, you simply need to define an injection point for it: <markup lang=\"java\" >import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject private NamedTopic&lt;Order&gt; orders; In the example above we&#8217;ve assumed that the topic name you want to inject is the same as the name of the field you are injecting into, in this case orders . If that&#8217;s not the case, you can use @Name qualifier to specify the name of the topic you want to obtain explicitly: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @Name(\"orders\") private NamedTopic&lt;Order&gt; topic; This is also what you have to do if you are using constructor or setter injection instead: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject public MyClass(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } @Inject public void setOrdersTopic(@Name(\"orders\") NamedTopic&lt;Order&gt; orders) { ... } All the examples above assume that you want to use the default scope, which is often, but not always the case. For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have multiple scopes. In this case you would use @SessionName qualifier to specify the name of the configured Session , that will be used to supply the topic: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionName; import com.tangosol.net.NamedTopic; import javax.inject.Inject; @Inject @SessionName(\"Finance\") private NamedTopic&lt;PaymentRequest&gt; payments; @Inject @SessionName(\"Shipping\") private NamedTopic&lt;ShippingRequest&gt; shipments; The examples above allow you to inject a NamedTopic instance into your CDI bean, but it is often simpler and more convenient to inject Publisher or Subscriber for a given topic instead. This can be easily accomplished by replacing NamedTopic&lt;T&gt; in any of the examples above with either Publisher&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Publisher&lt;Order&gt; orders; @Inject @Name(\"orders\") private Publisher&lt;Order&gt; m_orders; @Inject @SessionName(\"payments-cluster.xml\") private Publisher&lt;PaymentRequest&gt; payments; or Subscriber&lt;T&gt; : <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import com.oracle.coherence.cdi.SessionName; import javax.inject.Inject; @Inject private Subscriber&lt;Order&gt; orders; @Inject @Name(\"orders\") private Subscriber&lt;Order&gt; m_orders; @Inject @SessionName(\"Finance\") private Subscriber&lt;PaymentRequest&gt; payments; Topic metadata, such as topic name (based on either injection point name or the explicit name from @Name annotation), scope and message type, will be used under the hood to retrieve the NamedTopic , and to obtain Publisher or Subscriber from it. Additionally, if you want to place your Subscriber`s into a subscriber group (effectively turning a topic into a queue), you can easily accomplish that by adding `@SubscriberGroup qualifier to the injection point: <markup lang=\"java\" >import com.oracle.coherence.cdi.SubscriberGroup; import javax.inject.Inject; @Inject @SubscriberGroup(\"orders-queue\") private Subscriber&lt;Order&gt; orders; Other Supported Injection Points While the injection of a NamedMap , NamedCache , NamedTopic , and related instances, as shown above, is probably the single most used feature of Coherence CDI, it is certainly not the only one. The following sections describe other Coherence artifacts that can be injected using Coherence CDI. Cluster and OperationalContext Injection If you need an instance of a Cluster interface somewhere in your application, you can easily obtain it via injection: <markup lang=\"java\" >import com.tangosol.net.Cluster; import javax.inject.Inject; @Inject private Cluster cluster; You can do the same if you need an instance of an OperationalContext : <markup lang=\"java\" >import com.tangosol.net.OperationalContext; import javax.inject.Inject; @Inject private OperationalContext ctx; Named Session Injection On rare occasions when you need to use a Session directly, Coherence CDI makes it trivial to do so. Coherence will create a default Session when the CDI server starts, this will be created using the normal default cache configuration file. Other named sessions can be configured as CDI beans of type SessionConfiguration . For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class MySession implements SessionInitializer { public String getName() { return \"Foo\"; } // implement session configuration methods } The bean above will create the configuration for a Session named Foo . When the CDI server starts the session will be created and can then be injected into other beans. A simpler way to create a SessionConfiguration is to implement the SessionIntializer interface and annotate the class. For example: <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Scope; import com.oracle.coherence.cdi.SessionInitializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @ApplicationScoped @Named(\"Foo\") @Scope(\"Foo\") @ConfigUri(\"my-coherence-config.xml\") public class MySession implements SessionInitializer { } The above configuration will create a Session bean with a name of Foo a scoep of Foo with an underlying ConfigurableCacheFactory created from the my-coherence-config.xml configuration file. To obtain an instance of the default Session , all you need to do is inject it into the class which needs to use it: <markup lang=\"java\" >import com.tangosol.net.Session; import javax.inject.Inject; @Inject private Session session; If you need a specific named Session you can simply qualify one using @Name qualifier and specifying the Session name: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"SessionOne\") private Session sessionOne; @Inject @Name(\"SessionTwo\") private Session sessionTwo; Serializer Injection While in most cases you won&#8217;t have to deal with serializers directly, Coherence CDI makes it simple to obtain named serializers (and to register new ones) when you need. To get a default Serializer for the current context class loader, you can simply inject it: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.inject.Inject; @Inject private Serializer defaultSerializer; However, it may be more useful to inject one of the named serializers defined in the operational configuration, which can be easily accomplished using @Name qualifier: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"java\") private Serializer javaSerializer; @Inject @Name(\"pof\") private Serializer pofSerializer; In addition to the serializers defined in the operational config, the example above will also perform BeanManager lookup for a named bean that implements Serializer interface. That means that if you implemented a custom Serializer bean, such as: <markup lang=\"java\" >import com.tangosol.io.Serializer; import javax.enterprise.context.ApplicationScoped; import javax.inject.Named; @Named(\"json\") @ApplicationScoped public class JsonSerializer implements Serializer { ... } it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily as the named serializers defined in the operational config: <markup lang=\"java\" >import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"json\") private Serializer jsonSerializer; Inject a POF Serializer With a Specific POF Configuration POF serializers can be injected by using both the @Name and @ConfigUri qualifiers to inject a POF serializer which uses a specific POF configuration file. <markup lang=\"java\" >import com.oracle.coherence.cdi.ConfigUri; import com.oracle.coherence.cdi.Name; import javax.inject.Inject; @Inject @Name(\"pof\") @ConfigUri(\"test-pof-config.xml\") private Serializer pofSerializer; The code above will inject a POF serializer that uses test-pof-config.xml as its configuration file. Injecting CDI Beans into Coherence-managed Objects Coherence has a number of server-side extension points, which allow users to customize application behavior in different ways, typically by configuring their extensions within various sections of the cache configuration file. For example, the users can implement event interceptors and cache stores, in order to handle server-side events and integrate with the external data stores and other services. Coherence CDI provides a way to inject named CDI beans into these extension points using custom configuration namespace handler. <markup lang=\"xml\" >&lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xmlns:cdi=\"class://com.oracle.coherence.cdi.server.CdiNamespaceHandler\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; Once you&#8217;ve declared the handler for the cdi namespace above, you can specify &lt;cdi:bean&gt; element in any place where you would normally use &lt;class-name&gt; or &lt;class-factory-name&gt; elements: <markup lang=\"xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xmlns:cdi=\"class://com.oracle.coherence.cdi.server.CdiNamespaceHandler\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;registrationListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;activationListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;caching-scheme-mapping&gt; &lt;cache-mapping&gt; &lt;cache-name&gt;*&lt;/cache-name&gt; &lt;scheme-name&gt;distributed-scheme&lt;/scheme-name&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;cacheListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;/cache-mapping&gt; &lt;/caching-scheme-mapping&gt; &lt;caching-schemes&gt; &lt;distributed-scheme&gt; &lt;scheme-name&gt;distributed-scheme&lt;/scheme-name&gt; &lt;service-name&gt;PartitionedCache&lt;/service-name&gt; &lt;local-storage system-property=\"coherence.distributed.localstorage\"&gt;true&lt;/local-storage&gt; &lt;partition-listener&gt; &lt;cdi:bean&gt;partitionListener&lt;/cdi:bean&gt; &lt;/partition-listener&gt; &lt;member-listener&gt; &lt;cdi:bean&gt;memberListener&lt;/cdi:bean&gt; &lt;/member-listener&gt; &lt;backing-map-scheme&gt; &lt;local-scheme/&gt; &lt;/backing-map-scheme&gt; &lt;autostart&gt;true&lt;/autostart&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;cdi:bean&gt;storageListener&lt;/cdi:bean&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;/distributed-scheme&gt; &lt;/caching-schemes&gt; &lt;/cache-config&gt; Note that you can only inject named CDI beans (beans with an explicit @Named annotations) via &lt;cdi:bean&gt; element. For example, the cacheListener interceptor bean used above would look similar to this: <markup lang=\"java\" >@ApplicationScoped @Named(\"cacheListener\") @EntryEvents(INSERTING) public class MyCacheListener implements EventInterceptor&lt;EntryEvent&lt;Long, String&gt;&gt; { @Override public void onEvent(EntryEvent&lt;Long, String&gt; e) { // handle INSERTING event } } Also keep in mind that only @ApplicationScoped beans can be injected, which implies that they may be shared. For example, because we&#8217;ve used a wildcard, * , as a cache name within the cache mapping in the example above, the same instance of cacheListener will receive events from multiple caches. This is typically fine, as the event itself provides the details about the context that raised it, including cache name, and the service it was raised from, but it does imply that any shared state that you may have within your listener class shouldn&#8217;t be context-specific, and it must be safe for concurrent access from multiple threads. If you can&#8217;t guarantee the latter, you may want to declare the onEvent method as synchronized , to ensure only one thread at a time can access any shared state you may have. Using CDI Observers to Handle Coherence Server-Side Events While the above examples show that you can implement any Coherence EventInterceptor as a CDI bean and register it using &lt;cdi:bean&gt; element within the cache configuration file, Coherence CDI also provides a much simpler way to accomplish the same goal using standard CDI Events and Observers. For example, to observe events raised by a NamedMap with the name people , with keys of type Long and values of type Person , you would define a CDI observer such as this one: <markup lang=\"java\" >private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Observe Specific Event Types The observer method above will receive all events for the people map, but you can also control the types of events received using event qualifiers: <markup lang=\"java\" >private void onUpdate(@Observes @Updated @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle UPDATED events raised by the 'people' map/cache } private void onChange(@Observes @Inserted @Updated @Removed @MapName(\"people\") EntryEvent&lt;?, ?&gt; event) { // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache } Filter Observed Events The events observed can be restricted further by using a Coherence Filter . If a filter has been specified, the events will be filtered on the server and will never be sent to the client. The filter that will be used is specified using a qualifier annotation that is itself annotated with @FilterBinding . You can implement a Custom FilterBinding (recommended), or use a built-in @WhereFilter for convenience, which allows you to specify a filter using CohQL. For example to receive all event types in the people map, but only for People with a lastName property value of Smith , the built-in @WhereFilter annotation can be used: <markup lang=\"java\" >@WhereFilter(\"lastName = 'Smith'\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { // handle all events raised by the 'people' map/cache } Transform Observed Events When an event observer does not want to receive the full cache or map value in an event, the event can be transformed into a different value to be observed. This is achieved using a MapEventTransformer that is applied to the observer method using either an ExtractorBinding annotation or a MapEventTransformerBinding annotation. Transformation of events happens on the server so can make observer&#8217;s more efficient as they do not need to receive the original event with the full old and new values. Transforming Events Using ExtractorBinding Annotations An ExtractorBinding annotation is an annotation that represents a Coherence ValueExtractor . When an observer method has been annotated with an ExtractorBinding annotation the resulting ValueExtractor is applied to the event&#8217;s values and a new event will be returned to the observer containing just the extracted properties. For example, an event observer that is observing events from a map named people , but only requires the last name, the built in @PropertyExtractor annotation can be used. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { // handle all events raised by the 'people' map/cache } Unlike the previous examples above the received events of type EntryEvent&lt;Long, Person&gt; this method will receive events of type EntryEvent&lt;Long, String&gt; because the property extractor will be applied to the Person values in the original event to extract just the lastName property, creating a new event with String values. There are a number of built in ExtractorBinding annotations, and it is also possible to create custom ExtractorBinding annotation - see the Custom ExtractorBinding Annotations section below. Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be extracted, and the event will contain a List of the extracted property values. For example, if the Person also contains an address field of type Address that contains a city field, this can be extracted with a @ChainedExtractor annotation. By combining this with the @PropertyExtractor in the example above both the lastName and city can be observed in the event. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") @ChainedExtractor({\"address\", \"city\"}) private void onMapChange(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { // handle all events raised by the 'people' map/cache } Note, now the event is of type EntryEvent&lt;Long, List&lt;String&gt;&gt; because multiple extracted values will be returned the event value is a List and in this case both properties are of tyep String , so the value can be List&lt;String&gt; . Transforming Events Using MapEventTransformerBinding Annotations If more complex event transformations are required than just extracting properties from event values, a custom MapEventTransformerBinding can be created that will produce a custom MapEventTransformer instance that will be applied to the observer&#8217;s events. See the Custom MapEventTransformerBinding Annotations section below for details on how to create MapEventTransformerBinding annotations. Observe Events for Maps and Caches in Specific Services and Scopes In addition, to the @MapName qualifier, you can also use @ServiceName and @ScopeName qualifiers as a way to limit the events received. The examples above show only how to handle EntryEvent s, but the same applies to all other server-side event types: <markup lang=\"java\" >private void onActivated(@Observes @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@Observes @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@Observes @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people' map/cache } Using Asynchronous Observers All the examples above used synchronous observers by specifying @Observes qualifier for each observer method. However, Coherence CDI fully supports asynchronous CDI observers as well. All you need to do is replace @Observes with @ObservesAsync in any of the examples above. <markup lang=\"java\" >private void onActivated(@ObservesAsync @Activated LifecycleEvent event) { // handle cache factory activation } private void onCreatedPeople(@ObservesAsync @Created @MapName(\"people\") CacheLifecycleEvent event) { // handle creation of the 'people' map/cache } private void onExecuted(@ObservesAsync @Executed @MapName(\"people\") @Processor(Uppercase.class) EntryProcessorEvent event) { // intercept 'Uppercase` entry processor execution against 'people', map/cache } Warning Coherence events fall into two categories: pre- and post-commit events. All the events whose name ends with \"ing\" , such as Inserting , Updating , Removing or Executing are pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception, but in order to do so they must be synchronous to ensure that they are executed on the same thread that is executing the operation that triggered the event. That means that you can observe them using asynchronous CDI observers, but if you want to mutate the set of entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous CDI observer. Injecting CDI Beans into Transient Objects Using CDI to inject Coherence objects into your application classes, and CDI beans into Coherence-managed objects will allow you to support many use cases where dependency injection may be useful, but it doesn&#8217;t cover an important use case that is somewhat specific to Coherence. Coherence is a distributed system, and it uses serialization in order to send both the data and the processing requests from one cluster member (or remote client) to another, as well as to store data, both in memory and on disk. Processing requests, such as entry processors and aggregators, have to be deserialized on a target cluster member(s) in order to be executed. In some cases, they could benefit from dependency injection in order to avoid service lookups. Similarly, while the data is stored in a serialized, binary format, it may need to be deserialized into user supplied classes for server-side processing, such as when executing entry processors and aggregators. In this case, data classes can often also benefit from dependency injection (in order to support Domain-Driven Design (DDD), for example). While these transient objects are not managed by the CDI container, Coherence CDI does support their injection during deserialization, but for performance reasons requires that you explicitly opt-in by implementing com.oracle.coherence.cdi.Injectable interface. Making transient classes Injectable While not technically a true marker interface, Injectable can be treated as such for all intents and purposes. All you need to do is add it to the implements clause of your class in order for injection on deserialization to kick in: <markup lang=\"java\" >public class InjectableBean implements Injectable, Serializable { @Inject private Converter&lt;String, String&gt; converter; private String text; InjectableBean() { } InjectableBean(String text) { this.text = text; } String getConvertedText() { return converter.convert(text); } } Assuming that you have the following Converter service implementation in your application, it will be injected into InjectableBean during deserialization, and the getConvertedText method will return the value of the text field converted to upper case: <markup lang=\"java\" >@ApplicationScoped public class ToUpperConverter implements Converter&lt;String, String&gt; { @Override public String convert(String s) { return s.toUpperCase(); } } If your Injectable class has @PostConstruct callback method, it will be called after the injection. However, because we have no control over object&#8217;s lifecycle after that point, @PreDestroy callback will never be called). You should note that the above functionality is not dependent on the serialization format and will work with both Java and POF serialization (or any other custom serializer), and for any object that is deserialized on any Coherence member (or even on a remote client). While the deserialized transient objects are not true CDI managed beans, being able to inject CDI managed dependencies into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those application components. We hope you&#8217;ll find it useful. FilterBinding Annotations As already mentioned above, when creating views or subscribing to events, the view or events can be modified using Filters . The exact Filter implementation injected will be determined by the view or event observers qualifiers. Specifically any qualifier annotation that is itself annotated with the @FilterBinding annotation. This should be a familiar pattern to anyone who has worked with CDI interceptors. For example, if there is an injection point for a view that is a filtered view of an underlying map, but the filter required is more complex than those provided by the build in qualifiers, or is some custom filter implementation. The steps required are: Create a custom annotation class to represent the required Filter . Create a bean class implementing com.oracle.coherence.cdi.FilterFactory annotated with the custom annotation that will be the factory for producing instances of the custom Filter . Annotate the view injection point with the custom annotation. Create the Custom Filter Annotation Creating the filter annotation is simply creating a normal Java annotation class that is annotated with the @com.oracle.coherence.cdi.FilterBinding annotation. <markup lang=\"java\" >@Inherited @FilterBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomFilter { } The most important part is that this new annotation is annotated with FilterBinding so that the Coherence CDI extensions can recognise that it represents a Filter . Create the Custom Filter Factory Once the custom annotation has been created a FilterFactories implementation can be created that will be responsible for producing instances of the required Filter . <markup lang=\"java\" >@ApplicationScoped @CustomFilter static class CustomFilterSupplier implements FilterFactory&lt;CustomFilter, Object&gt; { @Override public Filter&lt;Object&gt; create(CustomFilter annotation) { return new CustomComplexFilter(); } } The CustomFilterSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomFilterSupplier class has been annotated with the new filter binding annotation @CustomFilter so that the Coherence CDI extension can locate it when it needs to create Filters . The CustomFilterSupplier implements the FilterFactories interface&#8217;s create method where it creates the custom Filter implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated FilterFactories , the injection point requiring the Filter can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomFilter private NamedMap&lt;Long, Person&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive events matching the same custom Filter then the method can be annotated with the same custom filter annotation. <markup lang=\"java\" >@CustomFilter private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, Person&gt; event) { ExtractorBinding Annotations Extractor bindings are annotations that are themselves annotated with @ExtractorBinding and are used in conjunction with an implementation of com.oracle.coherence.cdi.ExtractorFactory to produce Coherence ValueExtractor instances. There are a number of built-in extractor binding annotations in the Coherence CDI module and it is a simple process to provide custom implementations. Built-In ExtractorBinding Annotations PropertyExtractor The @PropertyExtractor annotation can used to obtain an extractor that extracts a named property from an object. The value field of the @PropertyExtractor annotation is name of the property to extract. For example, this @PropertyExtractor annotation represents a ValueExtractor that will extract the lastName property from a value. <markup lang=\"java\" >@PropertyExtractor(\"lastName\") The extractor produced will be an instance of com.tangosol.util.extractor.UniversalExtractor , so the example above is the same as calling: <markup lang=\"java\" >new UniversalExtractor(\"lastName\"); The @PropertyExtractor annotation can be applied multiple times to create a MultiExtractor that will extract a List of properties from a value. For example, if there was a map named people , where the map values are instances of Person , that has a firstName and a lastName property. The event observer below would observe events on that map, but the event received would only contain the event key, and a List containing the extracted firstName and lastName from the original event. where the event values will be a list of <markup lang=\"java\" >@PropertyExtractor(\"firstName\") @PropertyExtractor(\"lastName\") private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, List&lt;String&gt;&gt; event) { ChainedExtractor The @ChainedExtractor annotation can be used to extract a chain of properties. For example, a Person instance might contain an address property that contains a city property. The @ChainedExtractor takes the chain of fields to be extracted, in this case, extract the address from Person and then extract the city from the address . <markup lang=\"java\" >@ChainedExtractor(\"address\", \"city\") Each of the property names is used to create a UniversalExtractor , and the array of these extractors is used to create an instance of com.tangosol.util.extractor.ChainedExtractor . The example above would be the same as calling: <markup lang=\"java\" >UniversalExtractor[] chain = new UniversalExtractor[] { new UniversalExtractor(\"address\"), new UniversalExtractor(\"city\") }; ChainedExtractor extractor = new ChainedExtractor(chain); PofExtractor The @PofExtractor annotation can be used to produce extractors that can extract properties from POF encoded values. The value passed to the @PofExtractor annotation is the POF path to navigate to the property to extract. For example, if a Person value has been serialized using POF with a lastName property at index 4 a @PofExtractor annotation could be used like this: <markup lang=\"java\" >@PofExtractor(index = 4) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(null, 4); Sometimes (for example when dealing with certain types of Number ) the PofExtractor needs to know they type to be extracted. In this case the type value can be set in the @PofExtractor annotation. For example, if a Book value had a sales field of type Long at POF index 2, the sales field could be extracted using the following @PofExtractor annotation: <markup lang=\"java\" >@PofExtractor(index = {2}, type = Long.class) The code above will create a Coherence com.tangosol.util.extractor.PofExtractor equivalent to calling: <markup lang=\"java\" >com.tangosol.util.extractor.PofExtractor(Long.class, 2); The index value for a @PofExtractor annotation is an int array so multiple POF index values can be passed to navigate down a chain of properties to extract. For example if Person contained an Address at POF index 5 and Address contained a city property at POF index 3 the city could be extracted from a Person using the @PofExtractor annotation like this: <markup lang=\"java\" >@PofExtractor(index = {5, 3}) Alternatively if the value that will be extracted from is annotated with com.tangosol.io.pof.schema.annotation.PortableType and the POF serialization code for the class has been generated using the Coherence com.tangosol.io.pof.generator.PortableTypeGenerator then property names can be passed to the @PofExtractor annotation using its path field. For example to extract the lastName field from a POF serialized Person the @PofExtractor annotation can be used like this: <markup lang=\"java\" >@PofExtractor(path = \"lastName\") the address city example would be: <markup lang=\"java\" >@PofExtractor(path = {\"address\", \"city\"}) and the Book sales example would be: <markup lang=\"java\" >@PofExtractor(path = \"sales\", type Long.class) Custom ExtractorBinding Annotations When the built-in extractor bindings are not suitable, or when a custom ValueExtractor implementation is required, then a custom extractor binding annotation can be created with a corresponding com.oracle.coherence.cdi.ExtractorFactory implementation. The steps required are: Create a custom annotation class to represent the required ValueExtractor . Create a bean class implementing com.oracle.coherence.cdi.ExtractorFactory annotated with the custom annotation that will be the factory for producing instances of the custom ValueExtractor . Annotate the view injection point with the custom annotation. Create the Custom Extractor Annotation Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.ExtractorBinding annotation. <markup lang=\"java\" >@Inherited @ExtractorBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomExtractor { } The most important part is that this new annotation has been annotated with ExtractorBinding so that the Coherence CDI extensions can recognise that it represents a ValueExtractor . Create the Custom Extractor Factory Once the custom annotation has been created an ExtractorFactory implementation can be created that will be responsible for producing instances of the required ValueExtractor . <markup lang=\"java\" >@ApplicationScoped @CustomExtractor static class CustomExtractorSupplier implements ExtractorFactory&lt;CustomExtractor, Object, Object&gt; { @Override public ValueExtractor&lt;Object, Object&gt; create(CustomExtractor annotation) { return new CustomComplexExtractor(); } } The CustomExtractorSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomExtractorSupplier class has been annotated with the new extractor binding annotation @CustomExtractor so that the Coherence CDI extension can locate it when it needs to create ValueExtractor instances. The CustomExtractorSupplier implements the ExtractorFactory interface&#8217;s create method where it creates the custom ValueExtractor implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated ExtractorFactory , the injection point requiring the ValueExtractor can be annotated with the new annotation. <markup lang=\"java\" >@Inject @View @CustomExtractor private NamedMap&lt;Long, String&gt; people; As well as views, custom filter binding annotations can also be used for event observers. For example if there is an event observer method that should only receive transformed events using the custom extractor to transform the event: <markup lang=\"java\" >@CustomExtractor private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { MapEventTransformerBinding Annotations Coherence CDI supports event observers that can observe events for cache, or map, entries (see the Events section). The observer method can be annotated with a MapEventTransformerBinding annotation to indicate that the observer requires a transformer to be applied to the original event before it is observed. There are no built-in MapEventTransformerBinding annotations, this feature is to support use of custom MapEventTransformer implementations. The steps to create and use a MapEventTransformerBinding annotation are: Create a custom annotation class to represent the required MapEventTransformer . Create a bean class implementing com.oracle.coherence.cdi.MapEventTransformerFactory annotated with the custom annotation that will be the factory for producing instances of the custom MapEventTransformer . Annotate the view injection point with the custom annotation. Create the Custom Extractor Annotation Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with the @com.oracle.coherence.cdi.MapEventTransformerBinding annotation. <markup lang=\"java\" >@Inherited @MapEventTransformerBinding @Documented @Retention(RetentionPolicy.RUNTIME) public @interface CustomTransformer { } The most important part is that this new annotation has been annotated with MapEventTransformerBinding so that the Coherence CDI extensions can recognise that it represents a MapEventTransformer . Create the Custom Extractor Factory Once the custom annotation has been created an MapEventTransformerFactory implementation can be created that will be responsible for producing instances of the required MapEventTransformer . <markup lang=\"java\" >@ApplicationScoped @CustomTransformer static class CustomTransformerSupplier implements MapEventTransformerFactory&lt;CustomTransformer, Object, Object, Object&gt; { @Override public MapEventTransformer&lt;Object, Object, Object&gt; create(CustomTransformer annotation) { return new CustomComplexTransformer(); } } The CustomTransformerSupplier class has been annotated with @ApplicationScoped to make is discoverable by CDI. The CustomTransformerSupplier class has been annotated with the new extractor binding annotation @CustomTransformer so that the Coherence CDI extension can locate it when it needs to create MapEventTransformer instances. The CustomTransformerSupplier implements the MapEventTransformerFactory interface&#8217;s create method where it creates the custom MapEventTransformer implementation. Annotate the Injection Point Now there is both a custom annotation, and an annotated MapEventTransformerFactory , the observer method requiring the MapEventTransformer can be annotated with the new annotation. <markup lang=\"java\" >@CustomTransformer private void onPerson(@Observes @MapName(\"people\") EntryEvent&lt;Long, String&gt; event) { ",
            "title": "Usage"
        },
        {
            "location": "/coherence-jvisualvm/README",
            "text": " The Coherence-VisualVM plug-in provides management and monitoring of a single Coherence cluster using the VisualVM management utility. The plug-in aggregates Coherence MBean data and shows a concise operational view of a single Coherence cluster. Some management information is presented over time, which allows real-time analysis and troubleshooting. This version of the plugin requires VisualVM release 2.0.2 or later which is available from https://visualvm.github.io/ . ",
            "title": "Coherence VisualVM Plugin"
        },
        {
            "location": "/coherence-jvisualvm/README",
            "text": " You must have the following: Java JDK 1.8 Ant version &gt;= 1.9.9 Maven 3.6.3+ Git ",
            "title": "Pre-requisites"
        },
        {
            "location": "/coherence-jvisualvm/README",
            "text": " These instructions have been summarized from https://github.com/oracle/visualvm/blob/release202/README.md . Checkout the VisualVM repository <markup lang=\"shell\" >$ git clone https://github.com/oracle/visualvm.git Cloning into 'visualvm'... Checkout the release202 branch <markup lang=\"shell\" >$ cd visualvm $ git checkout release202 Switched to a new branch 'release202' Unzip the NetBeans Platform 11 <markup lang=\"shell\" >$ cd visualvm $ unzip nb111_platform_08102019.zip Build the Plugins <markup lang=\"shell\" >$ ant build-zip Unzip the artefacts <markup lang=\"shell\" >$ cd dist $ unzip visualvm.zip $ cd .. Generate the NBM&#8217;s <markup lang=\"shell\" >$ ant nbms Install into the local repository <markup lang=\"shell\" >$ mvn -DnetbeansInstallDirectory=dist/visualvm \\ -DnetbeansNbmDirectory=build/updates \\ -DgroupIdPrefix=org.graalvm.visualvm \\ -DforcedVersion=RELEASE202 org.apache.netbeans.utilities:nb-repository-plugin:populate See here for instructions on how to push the artefacts to a remote Maven repository. ",
            "title": "Generate the VisualVM dependencies"
        },
        {
            "location": "/coherence-jvisualvm/README",
            "text": " Ensure you change to a completely new directory to close the Coherence CE repository. Clone the Coherence CE repository <markup lang=\"shell\" >$ https://github.com/oracle/coherence.git Build the Plugin <markup lang=\"shell\" >$ cd coherence/prj/coherence-jvisualvm $ mvn clean install -P visualvm Install the Plugin The plugin will be available in the location target/coherence-jvisualvm-20.12.1.nbm Follow the instructions here to install the plugin. ",
            "title": "Build the VisualVM Plugin"
        },
        {
            "location": "/coherence-jvisualvm/README",
            "text": " As the libraries required to build the VisualVM plugin are not hosted on Maven Central, the plugin is not built by default when building Coherence. To build the plugin is a two step process: Generate the VisualVM dependencies Build Coherence CE enabling the visualvm profile. Pre-requisites You must have the following: Java JDK 1.8 Ant version &gt;= 1.9.9 Maven 3.6.3+ Git Generate the VisualVM dependencies These instructions have been summarized from https://github.com/oracle/visualvm/blob/release202/README.md . Checkout the VisualVM repository <markup lang=\"shell\" >$ git clone https://github.com/oracle/visualvm.git Cloning into 'visualvm'... Checkout the release202 branch <markup lang=\"shell\" >$ cd visualvm $ git checkout release202 Switched to a new branch 'release202' Unzip the NetBeans Platform 11 <markup lang=\"shell\" >$ cd visualvm $ unzip nb111_platform_08102019.zip Build the Plugins <markup lang=\"shell\" >$ ant build-zip Unzip the artefacts <markup lang=\"shell\" >$ cd dist $ unzip visualvm.zip $ cd .. Generate the NBM&#8217;s <markup lang=\"shell\" >$ ant nbms Install into the local repository <markup lang=\"shell\" >$ mvn -DnetbeansInstallDirectory=dist/visualvm \\ -DnetbeansNbmDirectory=build/updates \\ -DgroupIdPrefix=org.graalvm.visualvm \\ -DforcedVersion=RELEASE202 org.apache.netbeans.utilities:nb-repository-plugin:populate See here for instructions on how to push the artefacts to a remote Maven repository. Build the VisualVM Plugin Ensure you change to a completely new directory to close the Coherence CE repository. Clone the Coherence CE repository <markup lang=\"shell\" >$ https://github.com/oracle/coherence.git Build the Plugin <markup lang=\"shell\" >$ cd coherence/prj/coherence-jvisualvm $ mvn clean install -P visualvm Install the Plugin The plugin will be available in the location target/coherence-jvisualvm-20.12.1.nbm Follow the instructions here to install the plugin. ",
            "title": "Building the Plugin"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " In order to use Coherence gRPC client, you need to declare it as a dependency in your pom.xml . There also needs to be a corresponding Coherence server running the gRPC proxy for the client to connect to. <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-java-client&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; ",
            "title": "Usage"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " The Coherence Java gRPC Client is a library that allows a Java application to connect to a Coherence gRPC proxy server. Usage In order to use Coherence gRPC client, you need to declare it as a dependency in your pom.xml . There also needs to be a corresponding Coherence server running the gRPC proxy for the client to connect to. <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-java-client&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; ",
            "title": "Coherence Java gRPC Client"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " When client code has finished with a Session it can be closed to free up and close any gRPC requests that are still open by calling the session.close() method. This will also locally release (but not destroy) all Coherence resources manged by that Session . ",
            "title": "Close a Session"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " To obtain a Session that connects to a remote gRPC proxy the first requirement is a gRPC Channel . The client application must create the gRPC Channel with the required configuration corresponding to that required by the server (for example any security settings etc). The Channel can then be used to create a Session using the Coherence Session factory methods. The Session can ten be used to access remote resources. <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Session session = Session.create(GrpcSessions.channel(channel)); NamedMap&lt;String, String&gt; map = session.getMap(\"foo\"); The example above creates a simple gRPC channel to connect to localhost:1408 . A Session has been created with this channel by specifying the GrpcSessions.channel(channel) option. The Session can used as a normal Coherence Sessions to create, maps, caches and topics. Calls to Session.create() with the same parameters, in this case channel, will return the same Session instance. Most gRPC Channel implementations do not implement an equals() method so the same Session will only be returned for the exact same Channel instance. Close a Session When client code has finished with a Session it can be closed to free up and close any gRPC requests that are still open by calling the session.close() method. This will also locally release (but not destroy) all Coherence resources manged by that Session . ",
            "title": "Obtain a Remote Session"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " The Serializer used by the remote session will default to Java serialization, unless the system property coherence.pof.enabled is set to true , in which case POF will be used for the serializer. The serializer for a session can be set specifically when creating a Session . <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Serializer ser = new JsonSerializer(); String format = \"json\"; Session session = Session.create(GrpcSessions.channel(channel), GrpcSessions.serializer(ser, format)); In the example above a json serializer is being used. The GrpcSessions.serializer(ser, format) session option is used to specify the serializer and its format name. The format name will be used by the server to select the correct server side serializer to process the session requests and responses. The serializer format configured must also have a compatible serializer available on the server so that the server can deserialize message payloads. ",
            "title": "Specify a Serializer"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " In most cases a Coherence server only has a single ConfigurableCacheFactory , but it is possible to run multiple and hence multiple different cache services managed by a different ConfigurableCacheFactory . Typically, a scope name will be used to isolate different ConfigurableCacheFactory instances. A gRPC client session can be created for a specific server side scope name by specifying the scope as an option when creating the session. <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Session session = Session.create(GrpcSessions.channel(channel), GrpcSessions.scope(\"foo\")); In the example above the GrpcSessions.scope(\"foo\") option is used to specify that the Session created should connect to resources on the server managed by the ConfigurableCacheFactory with the scope foo . ",
            "title": "Specify a Scope Name"
        },
        {
            "location": "/coherence-java-client/README",
            "text": " The simplest way to access remote Coherence resources, such as a NamedMap when using the gRPC client is via a Coherence Session . Obtain a Remote Session To obtain a Session that connects to a remote gRPC proxy the first requirement is a gRPC Channel . The client application must create the gRPC Channel with the required configuration corresponding to that required by the server (for example any security settings etc). The Channel can then be used to create a Session using the Coherence Session factory methods. The Session can ten be used to access remote resources. <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Session session = Session.create(GrpcSessions.channel(channel)); NamedMap&lt;String, String&gt; map = session.getMap(\"foo\"); The example above creates a simple gRPC channel to connect to localhost:1408 . A Session has been created with this channel by specifying the GrpcSessions.channel(channel) option. The Session can used as a normal Coherence Sessions to create, maps, caches and topics. Calls to Session.create() with the same parameters, in this case channel, will return the same Session instance. Most gRPC Channel implementations do not implement an equals() method so the same Session will only be returned for the exact same Channel instance. Close a Session When client code has finished with a Session it can be closed to free up and close any gRPC requests that are still open by calling the session.close() method. This will also locally release (but not destroy) all Coherence resources manged by that Session . Specify a Serializer The Serializer used by the remote session will default to Java serialization, unless the system property coherence.pof.enabled is set to true , in which case POF will be used for the serializer. The serializer for a session can be set specifically when creating a Session . <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Serializer ser = new JsonSerializer(); String format = \"json\"; Session session = Session.create(GrpcSessions.channel(channel), GrpcSessions.serializer(ser, format)); In the example above a json serializer is being used. The GrpcSessions.serializer(ser, format) session option is used to specify the serializer and its format name. The format name will be used by the server to select the correct server side serializer to process the session requests and responses. The serializer format configured must also have a compatible serializer available on the server so that the server can deserialize message payloads. Specify a Scope Name In most cases a Coherence server only has a single ConfigurableCacheFactory , but it is possible to run multiple and hence multiple different cache services managed by a different ConfigurableCacheFactory . Typically, a scope name will be used to isolate different ConfigurableCacheFactory instances. A gRPC client session can be created for a specific server side scope name by specifying the scope as an option when creating the session. <markup lang=\"java\" >Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 1408) .usePlaintext() .build(); Session session = Session.create(GrpcSessions.channel(channel), GrpcSessions.scope(\"foo\")); In the example above the GrpcSessions.scope(\"foo\") option is used to specify that the Session created should connect to resources on the server managed by the ConfigurableCacheFactory with the scope foo . ",
            "title": "Access Coherence Resources"
        },
        {
            "location": "/docs/core/01_overview",
            "text": " Coherence has a number of core improvements documented in this section. fa-rocket Bootstrap API Bootstrap Coherence application. library_books Parallel Recovery Recover data from Coherence&#8217;s Persistence mechanism in parallel. fa-sitemap Portable Types Implement versioned data classes that can evolve over time. ",
            "title": "Overview"
        },
        {
            "location": "/coherence-grpc/README",
            "text": " Coherence gRPC provides the protobuf definitions necessary to interact with a Coherence data management services over gRPC. This library also provides utilities for making low-level cache requests over gRPC, converting between gRPC and Coherence binary implementations. Given this, unless there is a plan to develop a Coherence gRPC client in another language or to create new services in Java, there is little need for developers to depend on this library. ",
            "title": "Coherence gRPC"
        },
        {
            "location": "/coherence-grpc/README",
            "text": " In order to use Coherence gRPC, you need to declare it as a dependency in your pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-grpc&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; ",
            "title": "Usage"
        },
        {
            "location": "/coherence-grpc/README",
            "text": " Proto File Usage services.proto defines the RPCs for interacting with a Coherence data management services requests.proto defines the request/response structs for making requests to and receiving responses from Coherence data management services ",
            "title": "Protobuf Definitions"
        },
        {
            "location": "/docs/core/03_parallel_recovery",
            "text": " Coherence introduced a disk-based persistence feature from version 12.2.1. This feature accommodates for the loss of an entire cluster, and/or simultaneous loss of a primary and backup ensuring data is recovered from disk and made available. This process of making data available is parallel across the cluster with each storage member recovering a fair share of partitions. While this recovery is in parallel across different members/processes, each member uses a single thread to recover. As of version 20.12, Coherence now recovers data in parallel within a member/process as well as in parallel across the cluster. This allows the cluster, and more importantly the associated data, to be made available as quickly as possible. Ultimately the goal is to have recovery be only limited by the throughput and latency of underlying device. Therefore this feature does assume increasing usage of the device (by accessing data in parallel) will provide some benefit and reduce the overall time to recover data. The number of threads Coherence uses can be tweaked by the following JVM argument: coherence.distributed.persistence.recover.threads This argument may be removed in a future release as we work towards deriving an optimal value. The default value is based on the following formula: num-cores * (max-heap-size / machine-memory) + 2 ",
            "title": "Parallel Recovery"
        },
        {
            "location": "/coherence-mp/metrics/README",
            "text": " Coherence MP Metrics provides support for [Eclipse MicroProfile Metrics] ( https://microprofile.io/project/eclipse/microprofile-metrics ) within Coherence cluster members. This is a very simple module that allows you to publish Coherence metrics into MicroProfile Metric Registries available at runtime, and adds Coherence-specific tags to all the metrics published within the process, in order to distinguish them on the monitoring server, such as Prometheus. ",
            "title": "Coherence MicroProfile Metrics"
        },
        {
            "location": "/coherence-mp/metrics/README",
            "text": " In order to use Coherence MP Metrics, you need to declare it as a dependency in your pom.xml : <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-mp-metrics&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; That&#8217;s it&#8201;&#8212;&#8201;once the module above is in the class path, Coherence will discover MpMetricRegistryAdapter service it provides, and use it to publish all standard Coherence metrics to the vendor registry, and any user-defined application metrics to the application registry. All the metrics will be published as gauges, because they represent point-in-time values of various MBean attributes. ",
            "title": "Usage"
        },
        {
            "location": "/coherence-mp/metrics/README",
            "text": " There could be hundreds of members in a Coherence cluster, with each member publishing potentially the same set of metrics. There could also be many Coherence clusters in the environment, possibly publishing to the same monitoring server instance. In order to distinguish metrics coming from different clusters, as well as from different members of the same cluster, Coherence MP Metrics will automatically add several tags to ALL the metrics published within the process. The tags added are: Tag Name Tag Value cluster the cluster name site the site the member belongs to (if set) machine the machine member is on (if set) member the name of the member (if set) node_id the node ID of the member role the member&#8217;s role This ensures that the metrics published by one member do not collide with and overwrite the metrics published by another members, and allows you to query and aggregate metrics based on the values of the tags above if desired. ",
            "title": "Coherence Global Tags"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " Coherence gRPC proxy is the server-side implementation of the services defined within the Coherence gRPC module. The gRPC proxy uses standard gRPC Java libraries to provide Coherence APIs over gRPC. ",
            "title": "Coherence gRPC Server"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " The gRPC server will start automatically when com.tangosol.coherence.net.DefaultCacheServer is started. Typically, DefaultCacheServer will be used as the application&#8217;s main class, alternatively an instance of DefaultCacheServer can be started by calling its main() method directly from application initialisation code: <markup lang=\"java\" >import com.tangosol.net.DefaultCacheServer; public class MyApplication { public static void main(String[] args) { // do application initialisation... // this is a blocking call... DefaultCacheServer.main(args); } } or using the non-blocking startServerDaemon method: <markup lang=\"java\" >import com.tangosol.net.DefaultCacheServer; public class MyApplication { public static void main(String[] args) { // do application initialisation... DefaultCacheServer.startServerDaemon(); // do more application initialisation... } } When reviewing the log output, you should see the following two log messages: <markup lang=\"log\" >Coherence gRPC proxy is now listening for connections on 0.0.0.0:1408 Coherence gRPC in-process proxy 'default' is now listening for connections The service is now ready to process requests from one of the Coherence gRPC client implementations. ",
            "title": "Start the Server"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " In order to use Coherence gRPC Server, you need to declare it as a dependency of your project; for example if using Maven: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-grpc-proxy&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; or for Gradle: <markup lang=\"groovy\" >implementation 'com.oracle.coherence.ce:coherence-grpc-proxy:20.12.1' Start the Server The gRPC server will start automatically when com.tangosol.coherence.net.DefaultCacheServer is started. Typically, DefaultCacheServer will be used as the application&#8217;s main class, alternatively an instance of DefaultCacheServer can be started by calling its main() method directly from application initialisation code: <markup lang=\"java\" >import com.tangosol.net.DefaultCacheServer; public class MyApplication { public static void main(String[] args) { // do application initialisation... // this is a blocking call... DefaultCacheServer.main(args); } } or using the non-blocking startServerDaemon method: <markup lang=\"java\" >import com.tangosol.net.DefaultCacheServer; public class MyApplication { public static void main(String[] args) { // do application initialisation... DefaultCacheServer.startServerDaemon(); // do more application initialisation... } } When reviewing the log output, you should see the following two log messages: <markup lang=\"log\" >Coherence gRPC proxy is now listening for connections on 0.0.0.0:1408 Coherence gRPC in-process proxy 'default' is now listening for connections The service is now ready to process requests from one of the Coherence gRPC client implementations. ",
            "title": "Usage"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " The port the gRPC server listens on can be changed using the coherence.grpc.server.port system property, for example -Dcoherence.grpc.server.port=7001 will cause the server to bind to port 7001 . ",
            "title": "Set the Port"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " The name used by the in-process server can be changed using the coherence.grpc.inprocess.name system property, for example -Dcoherence.grpc.inprocess.name=foo will set the in-process server name to foo . ",
            "title": "Set the In-Process Server Name"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " It is possible to have full control over the configuration of the server by implementing the interface com.oracle.coherence.grpc.proxy.GrpcServerConfiguration . Implementations of this interface will be loaded using the Java ServiceLoader before the server starts allowing the ServerBuilder used to build both the server and in-process server to be modified. For example, the class below implements GrpcServerConfiguration and configures both servers to use transport security certificates. <markup lang=\"java\" title=\"MyServerConfig.java\" >package com.acme.application; import com.oracle.coherence.grpc.proxy.GrpcServerConfiguration; import io.grpc.ServerBuilder;import io.grpc.inprocess.InProcessServerBuilder; public class MyServerConfig implements GrpcServerConfiguration { public void configure(ServerBuilder&lt;?&gt; serverBuilder, InProcessServerBuilder inProcessServerBuilder) { File fileCert = new File(\"/grpc.crt\"); File fileKey = new File(\"grpc.key\"); serverBuilder.useTransportSecurity(fileCert, fileKey); inProcessServerBuilder.useTransportSecurity(fileCert, fileKey); } } For the Coherence gRPC proxy to find the above configuration class via the ServiceLoader a file named com.oracle.coherence.grpc.proxy.GrpcServerConfiguration needs to be added to application classes META-INF/services directory. <markup title=\"com.oracle.coherence.grpc.proxy.GrpcServerConfiguration\" >com.acme.application.MyServerConfig When the gRPC proxy starts it will now discover the MyServerConfig and will call it to modify the server builders. As well as security as in the example, other configuration such as interceptors and even additional gRPC services can be added to the server before it starts. ",
            "title": "Advanced gRPC Proxy Server Configuration"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " The default gRPC server will listen for remote connections on port 1408 as well as in-process connections on an in-process server named default . Set the Port The port the gRPC server listens on can be changed using the coherence.grpc.server.port system property, for example -Dcoherence.grpc.server.port=7001 will cause the server to bind to port 7001 . Set the In-Process Server Name The name used by the in-process server can be changed using the coherence.grpc.inprocess.name system property, for example -Dcoherence.grpc.inprocess.name=foo will set the in-process server name to foo . Advanced gRPC Proxy Server Configuration It is possible to have full control over the configuration of the server by implementing the interface com.oracle.coherence.grpc.proxy.GrpcServerConfiguration . Implementations of this interface will be loaded using the Java ServiceLoader before the server starts allowing the ServerBuilder used to build both the server and in-process server to be modified. For example, the class below implements GrpcServerConfiguration and configures both servers to use transport security certificates. <markup lang=\"java\" title=\"MyServerConfig.java\" >package com.acme.application; import com.oracle.coherence.grpc.proxy.GrpcServerConfiguration; import io.grpc.ServerBuilder;import io.grpc.inprocess.InProcessServerBuilder; public class MyServerConfig implements GrpcServerConfiguration { public void configure(ServerBuilder&lt;?&gt; serverBuilder, InProcessServerBuilder inProcessServerBuilder) { File fileCert = new File(\"/grpc.crt\"); File fileKey = new File(\"grpc.key\"); serverBuilder.useTransportSecurity(fileCert, fileKey); inProcessServerBuilder.useTransportSecurity(fileCert, fileKey); } } For the Coherence gRPC proxy to find the above configuration class via the ServiceLoader a file named com.oracle.coherence.grpc.proxy.GrpcServerConfiguration needs to be added to application classes META-INF/services directory. <markup title=\"com.oracle.coherence.grpc.proxy.GrpcServerConfiguration\" >com.acme.application.MyServerConfig When the gRPC proxy starts it will now discover the MyServerConfig and will call it to modify the server builders. As well as security as in the example, other configuration such as interceptors and even additional gRPC services can be added to the server before it starts. ",
            "title": "Configuration"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " As already stated above, the Coherence gRPC server will be started automatically based on DefaultCacheServer lifecycle events. This behaviour can be disabled by setting the coherence.grpc.enabled system property to false , in which case a gRPC server will not be started. ",
            "title": "Disabling the gRPC Proxy Server"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " If the coherence.grpc.enabled system property has been set to false , the gRPC server can be started manually by calling the start() method on the GrpcController singleton instance, for example: <markup lang=\"java\" >import com.oracle.coherence.grpc.proxy.GrpcServerController; public class MyApplication { public static void main(String[] args) { // do application initialisation... GrpcServerController.INSTANCE.start(); // do more application initialisation... } } The gRPC server can be stopped by calling the corresponding GrpcServerController.INSTANCE.stop() method. ",
            "title": "Programmatically starting the gRPC Proxy Server"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " If you have application code that needs to run only after the gRPC server has started this can be achieved by using the GrpcServerController.whenStarted() method. This method returns a CompletionStage that will be completed when the gRPC server has started. <markup lang=\"java\" >GrpcServerController.INSTANCE.whenStarted().thenRun(() -&gt; { // run post-start code... System.out.println(\"The gRPC server has started\"); }); ",
            "title": "Waiting For gRPC Server Start"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " If using the Helidon Microprofile server with the microprofile gRPC server enabled the Coherence gRPC proxy can be deployed into the Helidon gRPC server instead of the Coherence default gRPC server. For this behaviour to happen automatically just set the coherence.grpc.enabled system property to false , which will disable the built in server. A built-in GrpcMpExtension implementation will then deploy the proxy services to the Helidon gRPC server. When using the Helidon MP gRPC server, if the coherence.grpc.enabled system property has not been set to false , then both the Helidon gRPC server and the Coherence default gRPC server will start and could cause port binding issues unless they are both specifically configured to use different ports. ",
            "title": "Deploy the Proxy Service with Helidon Microprofile gRPC Server"
        },
        {
            "location": "/coherence-grpc-proxy/README",
            "text": " If you are running your own instance of a gRPC server and want to just deploy the Coherence gRPC proxy service to this server then that is possible. If manually deploying the service, ensure that auto-start of the Coherence gRPC server has been disabled by setting the system property coherence.grpc.enabled=false <markup lang=\"java\" >// Create your gRPC ServerBuilder ServerBuilder builder = ServerBuilder.forPort(port); // Obtain the Coherence gRPC services and add them to the builder List&lt;BindableService&gt; services = GrpcServerController.INSTANCE.createGrpcServices() services.forEach(serverBuilder::addService); // Build and start the server Server server = serverBuilder.build(); server.start(); ",
            "title": "Manually Deploy the gRPC Proxy Service"
        },
        {
            "location": "/coherence-micrometer/README",
            "text": " The coherence-micrometer module provides integration between Coherence metrics and Micrometer allowing Coherence metrics to be published via any of the Micrometer registries. ",
            "title": "Coherence Micrometer Metrics"
        },
        {
            "location": "/coherence-micrometer/README",
            "text": " In order to use Coherence Micrometer metrics, you need to declare the module as a dependency in your pom.xml and bind your Micrometer registry with the Coherence metrics adapter: <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-micrometer&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; The coherence-micrometer provides a Micrometer MeterBinder implementation class called CoherenceMicrometerMetrics . This class is a singleton and cannot be constructed, to access it use the CoherenceMicrometerMetrics.INSTANCE field. Micrometer provides many registry implementations to support different metrics applications and formats. For example, to bind Coherence metrics to the Micrometer PrometheusMeterRegistry , create the PrometheusMeterRegistry as documented in the Micrometer documentation , and call the CoherenceMicrometerMetrics class&#8217;s bindTo method: <markup lang=\"java\" >PrometheusMeterRegistry prometheusRegistry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT); // complete registy configuration... CoherenceMicrometerMetrics.INSTANCE.bindTo(prometheusRegistry); Micrometer registries can be bound to Coherence at any time, before or after Coherence starts. As Coherence creates or removed metrics they will be registered with or removed from the Micrometer registries. ",
            "title": "Usage"
        },
        {
            "location": "/coherence-micrometer/README",
            "text": " Micrometer has a global registry available which Coherence will bind to automatically if the coherence.micrometer.bind.to.global system property has been set to true (this property is false by default). ",
            "title": "Automatic Global Registry Binding"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " The com.tangol.net.Coherence contains a main method that allows it to be used to run a Coherence server as a more powerful to alternative DefaultCahceServer . <markup lang=\"bash\" >$ java -cp coherence.jar com.tangosol.net.Coherence Without any other configuration, the default Coherence instance started this way will run an identical server to that run using DefaultCahceServer . The steps above are covered in more detail below. ",
            "title": "Running A Coherence Server"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " When running Coherence if no configuration is specified the default behaviour is to use the default configuration file to configure Coherence. This behaviour still applies to the bootstrap API. If a Coherence instance is started without specifying any session configurations then a single default Session will be created. This default Session will wrap a ConfigurableCacheFactory that has been created from the default configuration file. The default file name is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig system property. When creating a CoherenceConfiguration the default session can be added using the SessionConfiguration.defaultSession() helper method. This method returns a SessionConfiguration configured to create the default Session . For example, in the code below the default session configuration is specifically added to the CoherenceConfiguration . <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); ",
            "title": "The Default Session"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " All sessions have a name that must be unique within the application. If a name has not been specified when the SessionConfiguration is built the default name of $Default$ will be used. A Coherence instance will fail to start if duplicate Session names exist. For example, this configuration will have the default name. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .build(); This configuration will have the name Test . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .name(\"Test\") .build(); ",
            "title": "Session Name"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " The most common type of session is a wrapper around a ConfigurableCacheFactory . When using the SessionConfiguration builder the configuration file URI is specified using the withConfigUri() method, that takes a string value specifiying the configuration file location. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"cache-config.xml\") .build(); The example above uses a configuration file a named cache-config.xml . If a configuration URI is not specified then the default value will be used. This value is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig System property. ",
            "title": "Session Configuration URI"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " Coherence provides many types of events, examples of a few would be life-cycle events for Coherence itself, cache life-cycle events, cache entry events, partition events etc. These events can be listened to by implementing an EventInterceptor that receives specific types of event. Event interceptors can be registered with a Session as part of its configuration. For example, suppose there is an interceptor class in the application called CacheInterceptor that listens to CacheLifecycleEvent when caches get created or destroyed. This interceptor can be added to the session as shown below: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withInterceptor(new CacheInterceptor()) .build(); The interceptor will receive cache life-cycle events for all caches created using the session. ",
            "title": "Session Event Interceptors"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " Scope is a concept that has been in Coherence for quite a while that allows services to be scoped and hence isolated from other services with the same name. For example multiple ConfigurableCacheFactory instances could be loaded from the same XML configuration file but given different scope names so that each CCF will have its own services in the cluster. Unless you require multiple Sessions, a scope will not generally be used in a configuration. A scope for a session can be configured using the configuration&#8217;s withScopeName() method, for example: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withScopeName(\"Test\") .build(); The session (and any ConfigurableCacheFactory it wraps) created from the configuration above will have a scope name of Test . It is possible to set a scope name in the &lt;defaults&gt; section of the XML configuration file. <markup lang=\"xml\" title=\"scoped-configuration.xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;defaults&gt; &lt;scope-name&gt;Test&lt;/scope-name&gt; &lt;/defaults&gt; A ConfigurableCacheFactory created from the XML above, and hence any Session that wraps it will have a scope of Test . Note When using the bootstrap API any scope name specifically configured in the SessionConfiguration (that is not the default scope name) will override the scope name in the XML file. For example, using the scoped-configuration.xml file above: In this case the scope name will be Foo because the scope name has been explicitly set in the SessionConfiguration . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .withScopeName(\"Foo\") .build(); In this case the scope name will be Foo because although no scope name has been explicitly set in the SessionConfiguration , the name has been set to Foo , so the scope name will default to Foo . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as no scope name or session name has been explicitly set in the SessionConfiguration so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as the session name has been set to Foo but the scope name has been explicitly set to the default scope name using the constant Coherence.DEFAULT_SCOPE so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withScopeName(Coherence.DEFAULT_SCOPE) .withConfigUri(\"scoped-configuration.xml\") .build(); ",
            "title": "Session Scope"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A SessionConfiguration is created by using the SessionConfiguration builder as shown in the example above. The Default Session When running Coherence if no configuration is specified the default behaviour is to use the default configuration file to configure Coherence. This behaviour still applies to the bootstrap API. If a Coherence instance is started without specifying any session configurations then a single default Session will be created. This default Session will wrap a ConfigurableCacheFactory that has been created from the default configuration file. The default file name is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig system property. When creating a CoherenceConfiguration the default session can be added using the SessionConfiguration.defaultSession() helper method. This method returns a SessionConfiguration configured to create the default Session . For example, in the code below the default session configuration is specifically added to the CoherenceConfiguration . <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); Session Name All sessions have a name that must be unique within the application. If a name has not been specified when the SessionConfiguration is built the default name of $Default$ will be used. A Coherence instance will fail to start if duplicate Session names exist. For example, this configuration will have the default name. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .build(); This configuration will have the name Test . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .name(\"Test\") .build(); Session Configuration URI The most common type of session is a wrapper around a ConfigurableCacheFactory . When using the SessionConfiguration builder the configuration file URI is specified using the withConfigUri() method, that takes a string value specifiying the configuration file location. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"cache-config.xml\") .build(); The example above uses a configuration file a named cache-config.xml . If a configuration URI is not specified then the default value will be used. This value is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig System property. Session Event Interceptors Coherence provides many types of events, examples of a few would be life-cycle events for Coherence itself, cache life-cycle events, cache entry events, partition events etc. These events can be listened to by implementing an EventInterceptor that receives specific types of event. Event interceptors can be registered with a Session as part of its configuration. For example, suppose there is an interceptor class in the application called CacheInterceptor that listens to CacheLifecycleEvent when caches get created or destroyed. This interceptor can be added to the session as shown below: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withInterceptor(new CacheInterceptor()) .build(); The interceptor will receive cache life-cycle events for all caches created using the session. Session Scope Scope is a concept that has been in Coherence for quite a while that allows services to be scoped and hence isolated from other services with the same name. For example multiple ConfigurableCacheFactory instances could be loaded from the same XML configuration file but given different scope names so that each CCF will have its own services in the cluster. Unless you require multiple Sessions, a scope will not generally be used in a configuration. A scope for a session can be configured using the configuration&#8217;s withScopeName() method, for example: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withScopeName(\"Test\") .build(); The session (and any ConfigurableCacheFactory it wraps) created from the configuration above will have a scope name of Test . It is possible to set a scope name in the &lt;defaults&gt; section of the XML configuration file. <markup lang=\"xml\" title=\"scoped-configuration.xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;defaults&gt; &lt;scope-name&gt;Test&lt;/scope-name&gt; &lt;/defaults&gt; A ConfigurableCacheFactory created from the XML above, and hence any Session that wraps it will have a scope of Test . Note When using the bootstrap API any scope name specifically configured in the SessionConfiguration (that is not the default scope name) will override the scope name in the XML file. For example, using the scoped-configuration.xml file above: In this case the scope name will be Foo because the scope name has been explicitly set in the SessionConfiguration . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .withScopeName(\"Foo\") .build(); In this case the scope name will be Foo because although no scope name has been explicitly set in the SessionConfiguration , the name has been set to Foo , so the scope name will default to Foo . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as no scope name or session name has been explicitly set in the SessionConfiguration so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as the session name has been set to Foo but the scope name has been explicitly set to the default scope name using the constant Coherence.DEFAULT_SCOPE so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withScopeName(Coherence.DEFAULT_SCOPE) .withConfigUri(\"scoped-configuration.xml\") .build(); ",
            "title": "Session Configurations"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A Coherence instance manages one or more Session instances, which are added to the CoherenceConfiguration by adding the SessionConfiguration instances to the builder. If no sessions have been added to the builder the Coherence instance will run a single Session that uses the default configuration file. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); The configuration above will configure a Coherence instance with the default name and with a single Sessions that wil use the default configuration file. The default session can also be explicitly added to the CoherenceConfiguration : <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); As already shown, other session configurations may also be added to the CoherenceConfiguration : <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(session) .build(); Whilst there is no limit to the number of sessions that can be configured the majority of applications would only ever require a single session - more than likely just the default session. ",
            "title": "Adding Sessions"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A CoherenceConfiguration can be configured to automatically discover SessionConfiguration instances. These are discovered using the Java ServiceLoader . Any instances of SessionConfiguration or SessionConfiguration.Provider configured as services in META-INF/services/ files will be loaded. This is useful if you are building modular applications where you want to include functionality in a separate application module that uses its own Session . The SessionConfiguration for the module is made discoverable by the ServiceLoader then whenever the module&#8217;s jar file is on the classpath the Session will be created, and the module&#8217;s functionality will be available to the application. For example: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .discoverSessions() .build(); The call to discoverSessions() will load discovered SessionConfiguration instances. ",
            "title": "Session Configuration Auto-Discovery"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " Each Coherence instance must be uniquely named. A name can be specified using the named() method on the builder, if no name has been specified the default name of $Default$ will be used. In the majority of use-cases an application would only ever require a single Coherence instance so there would be no requirement to specify a name. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .named(\"Carts\") .build(); The configuration above will create a Coherence instance with the name Carts . ",
            "title": "Coherence Instance Name"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " As already mentioned, event interceptors can be added to a SessionConfiguration to receive events for a session. Event interceptors can also be added to the Coherence instance to receive events for all Session instances managed by that Coherence instance. For example, reusing the previous CacheInterceptor class, but this time for caches in all sessions: <markup lang=\"java\" >SessionConfiguration cartsSession = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withSession(cartsSession) .withInterceptor(new CacheInterceptor()) .build(); Now the CacheInterceptor will receive events for both the default session and the Certs session. ",
            "title": "Add Global Event Interceptors"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A Coherence application is started by creating a Coherence instance from a CoherenceConfiguration . An instance of CoherenceConfiguration is created using the builder. For example: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Adding Sessions A Coherence instance manages one or more Session instances, which are added to the CoherenceConfiguration by adding the SessionConfiguration instances to the builder. If no sessions have been added to the builder the Coherence instance will run a single Session that uses the default configuration file. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); The configuration above will configure a Coherence instance with the default name and with a single Sessions that wil use the default configuration file. The default session can also be explicitly added to the CoherenceConfiguration : <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); As already shown, other session configurations may also be added to the CoherenceConfiguration : <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(session) .build(); Whilst there is no limit to the number of sessions that can be configured the majority of applications would only ever require a single session - more than likely just the default session. Session Configuration Auto-Discovery A CoherenceConfiguration can be configured to automatically discover SessionConfiguration instances. These are discovered using the Java ServiceLoader . Any instances of SessionConfiguration or SessionConfiguration.Provider configured as services in META-INF/services/ files will be loaded. This is useful if you are building modular applications where you want to include functionality in a separate application module that uses its own Session . The SessionConfiguration for the module is made discoverable by the ServiceLoader then whenever the module&#8217;s jar file is on the classpath the Session will be created, and the module&#8217;s functionality will be available to the application. For example: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .discoverSessions() .build(); The call to discoverSessions() will load discovered SessionConfiguration instances. Coherence Instance Name Each Coherence instance must be uniquely named. A name can be specified using the named() method on the builder, if no name has been specified the default name of $Default$ will be used. In the majority of use-cases an application would only ever require a single Coherence instance so there would be no requirement to specify a name. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .named(\"Carts\") .build(); The configuration above will create a Coherence instance with the name Carts . Add Global Event Interceptors As already mentioned, event interceptors can be added to a SessionConfiguration to receive events for a session. Event interceptors can also be added to the Coherence instance to receive events for all Session instances managed by that Coherence instance. For example, reusing the previous CacheInterceptor class, but this time for caches in all sessions: <markup lang=\"java\" >SessionConfiguration cartsSession = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withSession(cartsSession) .withInterceptor(new CacheInterceptor()) .build(); Now the CacheInterceptor will receive events for both the default session and the Certs session. ",
            "title": "Coherence Configuration"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " It is possible to create a Coherence instance without specifying any configuration. <markup lang=\"java\" >Coherence coherence = Coherence.clusterMember(); <markup lang=\"java\" >Coherence coherence = Coherence.client(); In both of the above examples the Coherence instance will have the default Session and any discovered sessions . ",
            "title": "Create a Default Coherence Instance"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A CoherenceConfiguration can be used to create a Coherence instance. A Coherence instance is created in one of two modes, either cluster member or client. The mode chosen affects how some types of Session are created and whether auto-start services are started. As the name suggests a \"cluster member\" is a Coherence instance that expects to start or join a Coherence cluster. In a cluster member any Session that wraps a ConfigurableCacheFactory will be have its services auto-started and monitored (this is the same behaviour that would have happened when using DefaultCacheServer to start a server). A \"client\" Coherence instance is typically not a cluster member, i.e. it is a Coherence*Extend or gRPC client. As such, Session instances that wrap a ConfigurableCacheFactory will not be auto-started, they will start on demand as resources such as maps, caches or topics are requested from them. The com.tangosol.net.Coherence class has static factory methods to create Coherence instances in different modes. For example, to create a Coherence instance that is a cluster member the Coherence.clusterMember method is used: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Coherence coherence = Coherence.clusterMember(cfg); For example, to create a Coherence instance that is a client the Coherence.client method is used: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Coherence coherence = Coherence.client(cfg); Create a Default Coherence Instance It is possible to create a Coherence instance without specifying any configuration. <markup lang=\"java\" >Coherence coherence = Coherence.clusterMember(); <markup lang=\"java\" >Coherence coherence = Coherence.client(); In both of the above examples the Coherence instance will have the default Session and any discovered sessions . ",
            "title": "Create a Coherence Instance"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " A Coherence instance it must be started to start all the sessions that the Coherence instance is managing. This is done by calling the start() method. <markup lang=\"java\" >Coherence coherence = Coherence.clusterMember(cfg); coherence.start(); ",
            "title": "Start Coherence"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " To avoid having to pass around the instance of Coherence that was used to bootstrap an application the Coherence class has some static methods that make it simple to retrieve an instance. If only a single instance of Coherence is being used in an application (which will cover most use-cases) then the getInstance() method can be used: <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(); It is also possible to retrieve an instance by name: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .named(\"Carts\") .build(); Coherence.create(cfg); &#8230;&#8203;then later&#8230;&#8203; <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(\"Carts\"); ",
            "title": "Obtaining a Coherence Instance"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " If application code needs to ensure that a Coherence instance has started before doing some work then the whenStarted() method can be used to obtain a CompletableFuture that will be completed when the Coherence instance has started. <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(\"Carts\"); CompletableFuture&lt;Void&gt; future = coherence.whenStarted(); future.join(); There is also a corresponding whenStopped() method that returns a future that will be completed when the Coherence instance stops. ",
            "title": "Ensuring Coherence Has Started"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " Besides using the future methods described above it is possible to add and EventInterceptor to the configuration of a Coherence instance that will receive life-cycle events. Below is an example interceptor that implements Coherence.LifecycleListener . <markup lang=\"java\" >public class MyInterceptor implements Coherence.LifecycleListener { public void onEvent(CoherenceLifecycleEvent event) { // process event } } The interceptor can be added to the configuration: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withInterceptor(new MyInterceptor()) .build(); When a Coherence instance created from this configuration is start or stopped the MyInterceptor instance will receive events. ",
            "title": "Coherence Lifecycle Interceptors"
        },
        {
            "location": "/docs/core/02_bootstrap",
            "text": " Coherence has a simple bootstrap API that allows a Coherence application to be configured and started by building a com.tangol.net.Coherence instance and starting it. The Coherence instance provides access to one or more com.tangosol.net.Session instances. A com.tangosol.net.Session gives access to Coherence clustered resources, such as NamedMap , NamedCache , NamedTopic etc. Sessions can be of different types, for example a session can be related to a ConfigurableCacheFactory , itself configured from a configuration file, or a session might be a client-side gRPC session. An example of some application bootstrap code might look like this: <markup lang=\"java\" >import com.tangosol.net.Coherence; import com.tangosol.net.CoherenceConfiguration; import com.tangosol.net.SessionConfiguration; public class Main { public static void main(String[] args) { // Create a Session configuration SessionConfiguration session = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); // Create a Coherence instance configuration CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withSession(session) .build(); // Create the Coherence instance from the configuration Coherence coherence = Coherence.clusterMember(cfg); // Start Coherence coherence.start(); } } A SessionConfiguration is created. In this case the Session will be named Carts and will be created from the cache-config.xml configuration file. A CoherenceConfiguration is created to configure the Coherence instance. This configuration contains the Carts session configuration. A Coherence cluster member instance is created from the CoherenceConfiguration The Coherence instance is started. Running A Coherence Server The com.tangol.net.Coherence contains a main method that allows it to be used to run a Coherence server as a more powerful to alternative DefaultCahceServer . <markup lang=\"bash\" >$ java -cp coherence.jar com.tangosol.net.Coherence Without any other configuration, the default Coherence instance started this way will run an identical server to that run using DefaultCahceServer . The steps above are covered in more detail below. Session Configurations A SessionConfiguration is created by using the SessionConfiguration builder as shown in the example above. The Default Session When running Coherence if no configuration is specified the default behaviour is to use the default configuration file to configure Coherence. This behaviour still applies to the bootstrap API. If a Coherence instance is started without specifying any session configurations then a single default Session will be created. This default Session will wrap a ConfigurableCacheFactory that has been created from the default configuration file. The default file name is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig system property. When creating a CoherenceConfiguration the default session can be added using the SessionConfiguration.defaultSession() helper method. This method returns a SessionConfiguration configured to create the default Session . For example, in the code below the default session configuration is specifically added to the CoherenceConfiguration . <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); Session Name All sessions have a name that must be unique within the application. If a name has not been specified when the SessionConfiguration is built the default name of $Default$ will be used. A Coherence instance will fail to start if duplicate Session names exist. For example, this configuration will have the default name. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .build(); This configuration will have the name Test . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .name(\"Test\") .build(); Session Configuration URI The most common type of session is a wrapper around a ConfigurableCacheFactory . When using the SessionConfiguration builder the configuration file URI is specified using the withConfigUri() method, that takes a string value specifiying the configuration file location. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"cache-config.xml\") .build(); The example above uses a configuration file a named cache-config.xml . If a configuration URI is not specified then the default value will be used. This value is coherence-cache-config.xml unless this has been overridden with the coherence.cacheconfig System property. Session Event Interceptors Coherence provides many types of events, examples of a few would be life-cycle events for Coherence itself, cache life-cycle events, cache entry events, partition events etc. These events can be listened to by implementing an EventInterceptor that receives specific types of event. Event interceptors can be registered with a Session as part of its configuration. For example, suppose there is an interceptor class in the application called CacheInterceptor that listens to CacheLifecycleEvent when caches get created or destroyed. This interceptor can be added to the session as shown below: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withInterceptor(new CacheInterceptor()) .build(); The interceptor will receive cache life-cycle events for all caches created using the session. Session Scope Scope is a concept that has been in Coherence for quite a while that allows services to be scoped and hence isolated from other services with the same name. For example multiple ConfigurableCacheFactory instances could be loaded from the same XML configuration file but given different scope names so that each CCF will have its own services in the cluster. Unless you require multiple Sessions, a scope will not generally be used in a configuration. A scope for a session can be configured using the configuration&#8217;s withScopeName() method, for example: <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withScopeName(\"Test\") .build(); The session (and any ConfigurableCacheFactory it wraps) created from the configuration above will have a scope name of Test . It is possible to set a scope name in the &lt;defaults&gt; section of the XML configuration file. <markup lang=\"xml\" title=\"scoped-configuration.xml\" >&lt;?xml version=\"1.0\"?&gt; &lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;defaults&gt; &lt;scope-name&gt;Test&lt;/scope-name&gt; &lt;/defaults&gt; A ConfigurableCacheFactory created from the XML above, and hence any Session that wraps it will have a scope of Test . Note When using the bootstrap API any scope name specifically configured in the SessionConfiguration (that is not the default scope name) will override the scope name in the XML file. For example, using the scoped-configuration.xml file above: In this case the scope name will be Foo because the scope name has been explicitly set in the SessionConfiguration . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .withScopeName(\"Foo\") .build(); In this case the scope name will be Foo because although no scope name has been explicitly set in the SessionConfiguration , the name has been set to Foo , so the scope name will default to Foo . <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as no scope name or session name has been explicitly set in the SessionConfiguration so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .withConfigUri(\"scoped-configuration.xml\") .build(); In this case the scope name will be Test as the session name has been set to Foo but the scope name has been explicitly set to the default scope name using the constant Coherence.DEFAULT_SCOPE so the scope name of Test will be used from the XML configuration. <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Foo\") .withScopeName(Coherence.DEFAULT_SCOPE) .withConfigUri(\"scoped-configuration.xml\") .build(); Coherence Configuration A Coherence application is started by creating a Coherence instance from a CoherenceConfiguration . An instance of CoherenceConfiguration is created using the builder. For example: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Adding Sessions A Coherence instance manages one or more Session instances, which are added to the CoherenceConfiguration by adding the SessionConfiguration instances to the builder. If no sessions have been added to the builder the Coherence instance will run a single Session that uses the default configuration file. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); The configuration above will configure a Coherence instance with the default name and with a single Sessions that wil use the default configuration file. The default session can also be explicitly added to the CoherenceConfiguration : <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .build(); As already shown, other session configurations may also be added to the CoherenceConfiguration : <markup lang=\"java\" >SessionConfiguration session = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(session) .build(); Whilst there is no limit to the number of sessions that can be configured the majority of applications would only ever require a single session - more than likely just the default session. Session Configuration Auto-Discovery A CoherenceConfiguration can be configured to automatically discover SessionConfiguration instances. These are discovered using the Java ServiceLoader . Any instances of SessionConfiguration or SessionConfiguration.Provider configured as services in META-INF/services/ files will be loaded. This is useful if you are building modular applications where you want to include functionality in a separate application module that uses its own Session . The SessionConfiguration for the module is made discoverable by the ServiceLoader then whenever the module&#8217;s jar file is on the classpath the Session will be created, and the module&#8217;s functionality will be available to the application. For example: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .discoverSessions() .build(); The call to discoverSessions() will load discovered SessionConfiguration instances. Coherence Instance Name Each Coherence instance must be uniquely named. A name can be specified using the named() method on the builder, if no name has been specified the default name of $Default$ will be used. In the majority of use-cases an application would only ever require a single Coherence instance so there would be no requirement to specify a name. <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .named(\"Carts\") .build(); The configuration above will create a Coherence instance with the name Carts . Add Global Event Interceptors As already mentioned, event interceptors can be added to a SessionConfiguration to receive events for a session. Event interceptors can also be added to the Coherence instance to receive events for all Session instances managed by that Coherence instance. For example, reusing the previous CacheInterceptor class, but this time for caches in all sessions: <markup lang=\"java\" >SessionConfiguration cartsSession = SessionConfiguration.builder() .named(\"Carts\") .withConfigUri(\"cache-config.xml\") .build(); CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withSession(cartsSession) .withInterceptor(new CacheInterceptor()) .build(); Now the CacheInterceptor will receive events for both the default session and the Certs session. Create a Coherence Instance A CoherenceConfiguration can be used to create a Coherence instance. A Coherence instance is created in one of two modes, either cluster member or client. The mode chosen affects how some types of Session are created and whether auto-start services are started. As the name suggests a \"cluster member\" is a Coherence instance that expects to start or join a Coherence cluster. In a cluster member any Session that wraps a ConfigurableCacheFactory will be have its services auto-started and monitored (this is the same behaviour that would have happened when using DefaultCacheServer to start a server). A \"client\" Coherence instance is typically not a cluster member, i.e. it is a Coherence*Extend or gRPC client. As such, Session instances that wrap a ConfigurableCacheFactory will not be auto-started, they will start on demand as resources such as maps, caches or topics are requested from them. The com.tangosol.net.Coherence class has static factory methods to create Coherence instances in different modes. For example, to create a Coherence instance that is a cluster member the Coherence.clusterMember method is used: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Coherence coherence = Coherence.clusterMember(cfg); For example, to create a Coherence instance that is a client the Coherence.client method is used: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .build(); Coherence coherence = Coherence.client(cfg); Create a Default Coherence Instance It is possible to create a Coherence instance without specifying any configuration. <markup lang=\"java\" >Coherence coherence = Coherence.clusterMember(); <markup lang=\"java\" >Coherence coherence = Coherence.client(); In both of the above examples the Coherence instance will have the default Session and any discovered sessions . Start Coherence A Coherence instance it must be started to start all the sessions that the Coherence instance is managing. This is done by calling the start() method. <markup lang=\"java\" >Coherence coherence = Coherence.clusterMember(cfg); coherence.start(); Obtaining a Coherence Instance To avoid having to pass around the instance of Coherence that was used to bootstrap an application the Coherence class has some static methods that make it simple to retrieve an instance. If only a single instance of Coherence is being used in an application (which will cover most use-cases) then the getInstance() method can be used: <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(); It is also possible to retrieve an instance by name: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .named(\"Carts\") .build(); Coherence.create(cfg); &#8230;&#8203;then later&#8230;&#8203; <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(\"Carts\"); Ensuring Coherence Has Started If application code needs to ensure that a Coherence instance has started before doing some work then the whenStarted() method can be used to obtain a CompletableFuture that will be completed when the Coherence instance has started. <markup lang=\"java\" >Coherence coherence = Coherence.getInstance(\"Carts\"); CompletableFuture&lt;Void&gt; future = coherence.whenStarted(); future.join(); There is also a corresponding whenStopped() method that returns a future that will be completed when the Coherence instance stops. Coherence Lifecycle Interceptors Besides using the future methods described above it is possible to add and EventInterceptor to the configuration of a Coherence instance that will receive life-cycle events. Below is an example interceptor that implements Coherence.LifecycleListener . <markup lang=\"java\" >public class MyInterceptor implements Coherence.LifecycleListener { public void onEvent(CoherenceLifecycleEvent event) { // process event } } The interceptor can be added to the configuration: <markup lang=\"java\" >CoherenceConfiguration cfg = CoherenceConfiguration.builder() .withSession(SessionConfiguration.defaultSession()) .withInterceptor(new MyInterceptor()) .build(); When a Coherence instance created from this configuration is start or stopped the MyInterceptor instance will receive events. ",
            "title": "Bootstrap API"
        },
        {
            "location": "/coherence-mp/config/README",
            "text": " Coherence MP Config provides support for [Eclipse MicroProfile Config] ( https://microprofile.io/project/eclipse/microprofile-config ) within Coherence cluster members. It allows you both to configure various Coherence parameters from the values specified in any of the supported config sources, and to use Coherence cache as another, mutable config source. ",
            "title": "Coherence MicroProfile Config"
        },
        {
            "location": "/coherence-mp/config/README",
            "text": " In order to use Coherence MP Config, you need to declare it as a dependency in your pom.xml : <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;com.oracle.coherence.ce&lt;/groupId&gt; &lt;artifactId&gt;coherence-mp-config&lt;/artifactId&gt; &lt;version&gt;20.12.1&lt;/version&gt; &lt;/dependency&gt; You will also need an implementation of the Eclipse MP Config specification as a dependency. For example, if you are using Helidon , add the following to your pom.xml : <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-config&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- optional: add it if you want YAML config file support --&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; ",
            "title": "Usage"
        },
        {
            "location": "/coherence-mp/config/README",
            "text": " Coherence provides a number of configuration properties that can be specified by the users in order to define certain attributes or to customize cluster member behavior at runtime. For example, attributes such as cluster and role name, as well as whether a cluster member should or should not store data, can be specified via system properties: -Dcoherence.cluster=MyCluster -Dcoherence.role=Proxy -Dcoherence.distributed.localstorage=false Most of these attributes can also be defined within the operational or cache configuration file. For example, you could define first two attributes, cluster name and role, within the operational config override file: <markup lang=\"xml\" > &lt;cluster-config&gt; &lt;member-identity&gt; &lt;cluster-name&gt;MyCluster&lt;/cluster-name&gt; &lt;role-name&gt;Proxy&lt;/role-name&gt; &lt;/member-identity&gt; &lt;/cluster-config&gt; While these two options are more than enough in most cases, there are some issues with them being the only way to configure Coherence: When you are using one of Eclipse MicroProfile implementations, such as Helidon as the foundation of your application, it would be nice to define some of Coherence configuration parameters along with your other configuration parameters, and not in the separate file or via system properties. In some environments, such as Kubernetes, Java system properties are cumbersome to use, and environment variables are a preferred way of passing configuration properties to containers. Unfortunately, neither of the two use cases above is supported out of the box, but that&#8217;s the gap Coherence MP Config is designed to fill. As long as you have coherence-mp-config and an implementation of Eclipse MP Config specification to your class path, Coherence will use any of the standard or custom config sources to resolve various configuration options it understands. Standard config sources in MP Config include META-INF/microprofile-config.properties file, if present in the class path, environment variables, and system properties (in that order, with the properties in the latter overriding the ones from the former). That will directly address problem #2 above, and allow you to specify Coherence configuration options via environment variables within Kubernetes YAML files, for example: <markup lang=\"yaml\" > containers: - name: my-app image: my-company/my-app:1.0.0 env: - name: COHERENCE_CLUSTER value: \"MyCluster\" - name: COHERENCE_ROLE value: \"Proxy\" - name: COHERENCE_DISTRIBUTED_LOCALSTORAGE value: \"false\" Of course, the above is just an example&#8201;&#8212;&#8201;if you are running your Coherence cluster in Kubernetes, you should really be using Coherence Operator instead, as it will make both the configuration and the operation of your Coherence cluster much easier. You will also be able to specify Coherence configuration properties along with the other configuration properties of your application, which will allow you to keep everything in one place, and not scattered across many files. For example, if you are writing a Helidon application, you can simply add coherence section to your application.yaml : <markup lang=\"yaml\" >coherence: cluster: MyCluster role: Proxy distributed: localstorage: false ",
            "title": "Configuring Coherence using MP Config"
        },
        {
            "location": "/coherence-mp/config/README",
            "text": " Coherence MP Config also provides an implementation of Eclipse MP Config ConfigSource interface, which allows you to store configuration parameters in a Coherence cache. This has several benefits: Unlike pretty much all of the default configuration sources, which are static, configuration options stored in a Coherence cache can be modified without forcing you to rebuild your application JARs or Docker images. You can change the value in one place, and it will automatically be visible and up to date on all the members. While the features above give you incredible amount of flexibility, we also understand that such flexibility is not always desired, and the feature is disabled by default. If you want to enable it, you need to do so explicitly, by registering CoherenceConfigSource as a global interceptor in your cache configuration file: <markup lang=\"xml\" >&lt;cache-config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.oracle.com/coherence/coherence-cache-config\" xsi:schemaLocation=\"http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd\"&gt; &lt;interceptors&gt; &lt;interceptor&gt; &lt;instance&gt; &lt;class-name&gt;com.oracle.coherence.mp.config.CoherenceConfigSource&lt;/class-name&gt; &lt;/instance&gt; &lt;/interceptor&gt; &lt;/interceptors&gt; &lt;!-- your cache mappings and schemes... --&gt; &lt;/cache-config&gt; Once you do that, CoherenceConfigSource will be activated as soon as your cache factory is initialized, and injected into the list of available config sources for your application to use via standard MP Config APIs. By default, it will be configured with a priority (ordinal) of 500, making it higher priority than all the standard config sources, thus allowing you to override the values provided via config files, environment variables and system properties. However, you have full control over that behavior and can specify different ordinal via coherence.mp.config.source.ordinal configuration property. ",
            "title": "Using Coherence Cache as a Config Source"
        }
 ]
}